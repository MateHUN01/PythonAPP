<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AeroDraw PRO v3.9 - Selection Tool</title>
    
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <style>
        :root {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --border-color: #333333;
            --accent-color: #2196F3;
            --glass-bg: rgba(20, 20, 20, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.8);
            --glass-blur: 15px;
            --modal-bg: #1a1a1a;
            --input-field-bg: #252525;
            --btn-hover: rgba(255, 255, 255, 0.15);
            --run-color: #2196F3;
            --selection-color: #00ffcc; /* Kijelölő keret színe */
        }

        body.light-mode {
            --bg-color: #f5f5f7;
            --text-color: #333333;
            --border-color: #d1d1d1;
            --glass-bg: rgba(255, 255, 255, 0.8);
            --glass-border: rgba(0, 0, 0, 0.05);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.1);
            --modal-bg: #ffffff;
            --input-field-bg: #e6e6e6;
            --btn-hover: rgba(0, 0, 0, 0.05);
            --run-color: #1976D2;
            --selection-color: #007766;
        }

        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; background-color: var(--bg-color); color: var(--text-color); height: 100vh; overflow: hidden; }

        /* --- CANVAS LAYERS --- */
        #canvas-wrapper {
            position: relative; width: 100%; height: 100%; background: var(--bg-color); overflow: hidden; cursor: crosshair;
            transition: all 0.3s ease;
        }
        #canvas-wrapper.square-mode {
            width: auto; aspect-ratio: 1 / 1; margin: 0 auto; border: 2px solid var(--accent-color);
            box-shadow: 0 0 50px rgba(0,0,0,0.5); max-height: calc(100vh - 160px); margin-top: 80px;
        }

        .drawing-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .drawing-layer.active { pointer-events: auto; }
        #background-layer { z-index: 0; background-color: #000000; transition: background-color 0.3s; }
        #preview-layer { z-index: 50; pointer-events: none; } /* Preview is topmost for selection UI */
        #onion-layer { z-index: 1; pointer-events: none; opacity: 0.3; filter: grayscale(100%); }

        /* --- LEBEGŐ PANELEK --- */
        .floating-panel {
            position: absolute; background: var(--glass-bg); backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border); padding: 10px; border-radius: 12px; display: flex; flex-direction: column; gap: 10px; z-index: 100; box-shadow: var(--glass-shadow);
        }
        .toolbar-left { top: 100px; left: 20px; width: 130px; }
        .layer-panel-right { top: 100px; right: 20px; width: 200px; max-height: 60vh; transition: opacity 0.3s; }
        .layer-panel-right.hidden { opacity: 0; pointer-events: none; }

        .tool-row { display: flex; gap: 5px; justify-content: center; }
        .tool-btn { width: 36px; height: 36px; border-radius: 8px; border: 1px solid var(--border-color); background: rgba(255,255,255,0.05); color: var(--text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.2s; flex-shrink: 0; }
        .tool-btn:hover, .tool-btn.active { background: var(--accent-color); color: white; border-color: transparent; }
        
        .hex-palette-container { display: flex; flex-direction: column; align-items: center; gap: -4px; margin: 5px 0; }
        .hex-row { display: flex; gap: 2px; }
        .hex-row:nth-child(even) { margin-left: 14px; }
        .hex-swatch { width: 26px; height: 26px; border-radius: 50%; cursor: pointer; border: 2px solid rgba(255,255,255,0.1); transition: all 0.2s ease; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .hex-swatch:hover { transform: scale(1.2); z-index: 2; }
        .hex-swatch.active { border-color: white; box-shadow: 0 0 10px var(--accent-color); z-index: 3; transform: scale(1.1); }

        input[type="color"] { -webkit-appearance: none; padding: 0; height: 30px; width: 100%; cursor: pointer; border: 2px solid var(--border-color); background: transparent; border-radius: 8px; overflow: hidden; margin-top: 5px;}

        .layer-list { display: flex; flex-direction: column-reverse; gap: 5px; overflow-y: auto; flex: 1; }
        .layer-item { display: flex; align-items: center; justify-content: space-between; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 8px; border: 1px solid transparent; cursor: pointer; font-size: 13px; }
        .layer-item.active { border-color: var(--accent-color); background: rgba(33, 150, 243, 0.1); }
        .layer-item .layer-name { flex: 1; margin-left: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .layer-actions button { padding: 2px; background: transparent; border: none; color: #ff5555; opacity: 0.6; cursor: pointer; }
        .layer-actions button:hover { opacity: 1; }

        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; border-radius: 2px; background: #444; outline: none; margin-top: 5px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--accent-color); cursor: pointer; }

        #animation-panel { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 80%; height: 110px; background: var(--glass-bg); backdrop-filter: blur(var(--glass-blur)); border: 1px solid var(--glass-border); border-radius: 16px; display: none; flex-direction: column; padding: 10px; z-index: 100; box-shadow: var(--glass-shadow); }
        #animation-panel.active { display: flex; }
        .timeline-controls { display: flex; justify-content: center; gap: 10px; margin-bottom: 10px; align-items: center; flex-wrap: wrap;}
        .timeline-frames { display: flex; overflow-x: auto; gap: 5px; padding-bottom: 5px; align-items: center; }
        .timeline-frames::-webkit-scrollbar { height: 6px; }
        .timeline-frames::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        .frame-thumb { min-width: 50px; height: 50px; background: #000; border: 2px solid #444; border-radius: 6px; cursor: pointer; position: relative; overflow: hidden; }
        .frame-thumb.active { border-color: var(--accent-color); box-shadow: 0 0 10px var(--accent-color); }
        .frame-thumb canvas { width: 100%; height: 100%; object-fit: contain; }
        .frame-number { position: absolute; bottom: 2px; right: 2px; font-size: 9px; color: white; background: rgba(0,0,0,0.6); padding: 1px 3px; border-radius: 4px; }
        .anim-btn { padding: 5px 10px; background: var(--btn-hover); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 6px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 5px; }
        .anim-btn:hover { background: var(--accent-color); color: white; }
        .anim-btn.record { color: #ff5555; border-color: #ff5555; }
        .anim-btn.play { color: #50fa7b; border-color: #50fa7b; font-weight: bold; }
        .anim-btn.play.playing { background: #50fa7b; color: #121212; }

        #live-indicator { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); background: rgba(80, 250, 123, 0.1); color: #50fa7b; border: 1px solid #50fa7b; padding: 2px 12px; border-radius: 20px; font-size: 11px; font-weight: bold; pointer-events: none; z-index: 50; display: none; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        .header-wrapper { position: fixed; top: 25px; left: 0; width: 100%; display: flex; justify-content: space-between; padding: 0 40px; z-index: 1000; pointer-events: none; }
        .glass-bubble { pointer-events: auto; background: var(--glass-bg); backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur)); border: 1px solid var(--glass-border); box-shadow: var(--glass-shadow); border-radius: 100px; padding: 6px 10px; display: flex; align-items: center; gap: 10px; transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .glass-bubble:hover { transform: translateY(-2px); box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.8); }
        .app-title { font-weight: 700; font-size: 14px; padding-left: 15px; padding-right: 10px; letter-spacing: 0.5px; color: var(--text-color); display: flex; align-items: center; gap: 8px; }
        .vertical-divider { width: 1px; height: 24px; background-color: rgba(255,255,255,0.2); margin: 0 5px; }
        button.icon-btn { background: transparent; border: none; color: var(--text-color); width: 42px; height: 42px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; position: relative;}
        button.icon-btn:hover { background: var(--btn-hover); transform: scale(1.1); }
        button.icon-btn.active-mode { background: var(--accent-color); color: white; box-shadow: 0 0 10px var(--accent-color); }
        button.icon-btn:disabled { opacity: 0.3; cursor: default; transform: none; }
        #user-btn { cursor: pointer; font-size:12px; opacity:0.8; margin-right:5px; padding: 6px 12px; border-radius: 20px; transition: background 0.2s; font-weight:600; letter-spacing:0.5px; }
        #user-btn:hover { background: var(--btn-hover); opacity: 1; }

        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { opacity: 0; visibility: hidden; position: absolute; right: 0; top: 50px; background-color: var(--glass-bg); backdrop-filter: blur(var(--glass-blur)); min-width: 280px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.6); border-radius: 12px; border: 1px solid var(--glass-border); z-index: 2000; overflow: hidden; transition: all 0.2s ease-in-out; transform: translateY(-10px) scale(0.98); padding: 10px; cursor: default; }
        .dropdown:hover .dropdown-content { opacity: 1; visibility: visible; transform: translateY(0) scale(1); }
        .menu-item { color: var(--text-color); padding: 12px 16px; text-decoration: none; display: flex; align-items: center; gap: 10px; font-size: 13px; transition: background 0.2s; cursor: pointer; border-radius: 6px; }
        .menu-item:hover { background-color: var(--accent-color); color: white; }

        .user-chip-container { display: flex; flex-direction: column; gap: 5px; margin-top: 10px; margin-bottom: 10px; }
        .user-chip { background: rgba(255, 255, 255, 0.1); padding: 6px 10px; border-radius: 20px; font-size: 12px; display: flex; align-items: center; justify-content: space-between; border: 1px solid transparent; }
        .user-chip.self { border-color: var(--accent-color); }
        .user-chip .username { font-weight: 600; }
        .user-chip .kick-btn { background: transparent; border: none; color: #ff5555; cursor: pointer; display: flex; align-items: center; padding: 2px; border-radius: 50%; }

        .main-container { display: flex; height: 100vh; width: 100%; }
        .editor-container { flex: 1; display: flex; flex-direction: column; background: var(--bg-color); min-width: 0; position: relative; }
        
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 10001; backdrop-filter: blur(8px); justify-content: center; align-items: center; }
        .modal { background: var(--modal-bg); width: 350px; padding: 25px; border-radius: 24px; border: 1px solid var(--border-color); box-shadow: 0 20px 50px rgba(0,0,0,0.7); }
        .modal button { background: var(--accent-color); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; float: right; margin-top: 15px; font-weight: 600; }
        .modal input { width: 100%; padding: 12px; background: var(--input-field-bg); border: 1px solid var(--border-color); color: var(--text-color); border-radius: 8px; margin-bottom: 10px; outline: none;}
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-color); z-index: 9998; display: none; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.5s ease; }
        .gear { width: 60px; height: 60px; fill: var(--accent-color); animation: spin 2s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <svg class="gear" viewBox="0 0 512 512"><path d="M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"/></svg>
        <div id="loading-text" style="margin-top:20px; color:#666">Mentés...</div>
    </div>

    <div class="header-wrapper">
        <div class="glass-bubble left-bubble">
            <div class="app-title">
                <span class="material-icons" style="color:var(--accent-color)">draw</span>
                AeroDraw PRO v3.9
            </div>
            <div class="vertical-divider"></div>
            
            <button class="icon-btn" id="btn-undo" onclick="undoLastAction()" title="Visszavonás"><span class="material-icons">undo</span></button>
            <button class="icon-btn" id="btn-redo" onclick="redoLastAction()" title="Visszavonás visszavonása"><span class="material-icons">redo</span></button>
            <div class="vertical-divider" style="height: 16px; margin: 0 2px; opacity: 0.5;"></div>
            
            <button class="icon-btn" onclick="clearCurrentLayer()" title="Réteg Törlése"><span class="material-icons">delete</span></button>
            <button class="icon-btn" onclick="downloadImage()" title="Mentés képként"><span class="material-icons">image</span></button>
            
            <div class="vertical-divider" style="height: 16px; margin: 0 2px; opacity: 0.5;"></div>
            <button class="icon-btn" id="btn-anim-toggle" onclick="toggleAnimationMode()" title="Animációs Mód (GIF)"><span class="material-icons">movie_creation</span></button>
        </div>

        <div class="glass-bubble right-bubble">
            <div id="user-btn" onclick="openLoginModal()">Log in</div>
            <div class="dropdown">
                <button class="icon-btn" title="Közös Rajzolás (P2P)" onclick="resetP2PUI()">
                    <span class="material-icons">group</span>
                </button>
                <div class="dropdown-content">
                    <h4 style="margin:0 0 10px 0; border-bottom:1px solid #444; padding-bottom:5px;">Közös Rajzolás</h4>
                    <div id="connect-ui">
                        <div style="font-size:11px; opacity:0.7; margin-bottom:5px">Válassz egy csatornát:</div>
                        <select id="channel-select" style="width:100%; padding:8px; background:var(--input-field-bg); border:1px solid var(--border-color); color:var(--text-color); border-radius:4px; margin-bottom:10px; font-family:'Inter'">
                            <option value="1">1. Csatorna (Alpha)</option>
                            <option value="2">2. Csatorna (Beta)</option>
                            <option value="3">3. Csatorna (Gamma)</option>
                        </select>
                        <div style="display:flex; justify-content: space-between; align-items:center; margin-bottom:10px;">
                            <span style="font-size:11px; opacity:0.7;">Max létszám:</span>
                            <input type="number" id="room-size-limit" min="2" max="10" value="3" style="width:60px; padding:4px; font-size:11px; margin-bottom:0;">
                        </div>
                        <div style="font-size:10px; color:#ff5555; margin-bottom:10px; display:none;" id="login-warning">Jelentkezz be a csatlakozáshoz!</div>
                        <div style="display:flex; gap:5px;">
                            <button onclick="startAsHost()" style="flex:1; padding:8px; background:var(--run-color); color:white; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">HOST</button>
                            <button onclick="joinAsGuest()" style="flex:1; padding:8px; background:#50fa7b; color:#222; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">JOIN</button>
                        </div>
                    </div>
                    <div id="disconnect-ui" style="display:none;">
                        <div style="background:rgba(80, 250, 123, 0.1); color:#50fa7b; padding:8px; border-radius:4px; margin-bottom:10px; text-align:center; font-size:12px;">
                            <span class="material-icons" style="font-size:12px; vertical-align:middle;">link</span> Kapcsolódva
                        </div>
                        <div id="active-users-list" class="user-chip-container"></div>
                        <button onclick="disconnectPeer()" style="width:100%; padding:8px; background:#ff5555; color:white; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">Szétkapcsolás</button>
                    </div>
                    <div id="p2p-log" style="font-size:10px; color:#888; margin-top:10px; font-style:italic;">Offline</div>
                </div>
            </div>
            <div class="dropdown">
                <button class="icon-btn" title="Felhő Mentés">
                    <span class="material-icons">cloud_queue</span>
                </button>
                <div class="dropdown-content">
                    <a class="menu-item" onclick="handleDriveSave()"><span class="material-icons">save</span> Mentés Drive-ra (Kép)</a>
                </div>
            </div>
            <button class="icon-btn" onclick="toggleTheme()" title="Téma"><span class="material-icons">dark_mode</span></button>
            <button class="icon-btn" onclick="openSettings()" title="Beállítások"><span class="material-icons">settings</span></button>
        </div>
    </div>

    <div class="main-container">
        <div class="editor-container">
            <div id="live-indicator">● LIVE P2P</div>
            
            <div id="canvas-wrapper">
                <canvas id="background-layer" class="drawing-layer"></canvas>
                <canvas id="onion-layer" class="drawing-layer"></canvas>
                <canvas id="preview-layer" class="drawing-layer"></canvas>
            </div>

            <div class="floating-panel toolbar-left">
                <div class="tool-row">
                    <button class="tool-btn active" id="btn-brush" onclick="setTool('brush')" title="Ecset"><span class="material-icons">brush</span></button>
                    <button class="tool-btn" id="btn-eraser" onclick="setTool('eraser')" title="Radír"><span class="material-icons">auto_fix_normal</span></button>
                    <button class="tool-btn" id="btn-fill" onclick="setTool('fill')" title="Kitöltés"><span class="material-icons">format_color_fill</span></button>
                    <button class="tool-btn" id="btn-select" onclick="setTool('select')" title="Kijelölő (Lasso)"><span class="material-icons">gesture</span></button>
                </div>

                <div style="width:100%; height:1px; background:var(--border-color); margin:5px 0;"></div>

                <div class="hex-palette-container">
                    <div class="hex-row">
                        <div class="hex-swatch active" style="background:#ffffff" onclick="pickColor('#ffffff', this)"></div>
                        <div class="hex-swatch" style="background:#888888" onclick="pickColor('#888888', this)"></div>
                        <div class="hex-swatch" style="background:#000000" onclick="pickColor('#000000', this)"></div>
                    </div>
                     <div class="hex-row">
                        <div class="hex-swatch" style="background:#ff5555" onclick="pickColor('#ff5555', this)"></div>
                        <div class="hex-swatch" style="background:#ffaa55" onclick="pickColor('#ffaa55', this)"></div>
                        <div class="hex-swatch" style="background:#ffff55" onclick="pickColor('#ffff55', this)"></div>
                    </div>
                     <div class="hex-row">
                        <div class="hex-swatch" style="background:#55ff55" onclick="pickColor('#55ff55', this)"></div>
                        <div class="hex-swatch" style="background:#55ffff" onclick="pickColor('#55ffff', this)"></div>
                        <div class="hex-swatch" style="background:#2196F3" onclick="pickColor('#2196F3', this)"></div>
                    </div>
                    <div class="hex-row">
                        <div class="hex-swatch" style="background:#9c27b0" onclick="pickColor('#9c27b0', this)"></div>
                        <div class="hex-swatch" style="background:#e91e63" onclick="pickColor('#e91e63', this)"></div>
                        <div class="hex-swatch" style="background:#795548" onclick="pickColor('#795548', this)"></div>
                    </div>
                </div>
                
                <input type="color" id="pen-color-input" value="#ffffff" title="Egyedi szín">
                <div style="text-align:center; font-size:9px; opacity:0.7; margin-bottom:5px;">Vászon Háttér</div>
                <input type="color" id="canvas-bg-picker" value="#000000" title="Vászon háttérszíne" onchange="changeCanvasBg(this.value)" style="margin-top:0;">
                
                <div style="width:100%; height:1px; background:var(--border-color); margin:5px 0;"></div>
                
                <div class="tool-row">
                    <button class="tool-btn" id="btn-rect" onclick="setTool('rect')" title="Kocka"><span class="material-icons">crop_square</span></button>
                    <button class="tool-btn" id="btn-circle" onclick="setTool('circle')" title="Kör"><span class="material-icons">radio_button_unchecked</span></button>
                    <button class="tool-btn" id="btn-line" onclick="setTool('line')" title="Vonal"><span class="material-icons">horizontal_rule</span></button>
                </div>
                <div class="tool-row" style="margin-top:5px;">
                     <button class="tool-btn" id="btn-hexagon" onclick="setTool('hexagon')" title="Hatszög"><span class="material-icons">hexagon</span></button>
                </div>
                
                <div style="padding:0 5px; margin-top:5px;">
                    <label style="font-size:9px; opacity:0.7;">Méret</label>
                    <input type="range" id="pen-width" min="1" max="50" value="5">
                </div>
            </div>

            <div class="floating-panel layer-panel-right">
                <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid var(--border-color); padding-bottom:5px;">
                    <span style="font-weight:600; font-size:12px;">RÉTEGEK</span>
                    <button class="icon-btn" style="width:24px; height:24px;" onclick="addNewLayer()" title="Új réteg">+</button>
                </div>
                <div id="layer-list-container" class="layer-list">
                </div>
            </div>

            <div id="animation-panel">
                <div class="timeline-controls">
                    <button class="anim-btn play" id="btn-play" onclick="togglePlayAnimation()"><span class="material-icons">play_arrow</span> Lejátszás</button>
                    <div style="display:flex; align-items:center; gap:5px; margin-left:5px;">
                        <span style="font-size:10px; opacity:0.7;">FPS:</span>
                        <input type="number" id="fps-input" value="5" min="1" max="24" style="width:40px; padding:3px; background:var(--input-field-bg); color:var(--text-color); border:1px solid var(--border-color); border-radius:4px;">
                    </div>

                    <div style="width:1px; height:20px; background:var(--border-color); margin:0 10px;"></div>

                    <button class="anim-btn" onclick="animPrevFrame()"><span class="material-icons" style="font-size:16px">chevron_left</span></button>
                    <span id="frame-counter" style="font-size:12px; font-weight:600; min-width:50px; text-align:center;">1 / 1</span>
                    <button class="anim-btn" onclick="animNextFrame()"><span class="material-icons" style="font-size:16px">chevron_right</span></button>
                    
                    <div style="width:1px; height:20px; background:var(--border-color); margin:0 10px;"></div>
                    
                    <button class="anim-btn" onclick="animAddFrame()"><span class="material-icons" style="font-size:16px">add_box</span> Új Kép</button>
                    <button class="anim-btn" onclick="animDeleteFrame()"><span class="material-icons" style="font-size:16px">delete</span></button>
                    <button class="anim-btn" onclick="animToggleOnion()"><span class="material-icons" style="font-size:16px" id="onion-icon">layers</span> Hagymahéj</button>
                    
                    <div style="width:1px; height:20px; background:var(--border-color); margin:0 10px;"></div>

                    <button class="anim-btn record" onclick="renderGIF()"><span class="material-icons" style="font-size:16px">download</span> GIF Mentés</button>
                </div>
                <div class="timeline-frames" id="timeline-container"></div>
            </div>

        </div>
    </div>

    <div id="settingsModal" class="modal-overlay">
        <div class="modal">
            <h3 style="margin-top:0; color:var(--text-color)">Beállítások</h3>
            <p style="font-size:12px; opacity:0.7">Jelenleg nincs további beállítás.</p>
            <button onclick="document.getElementById('settingsModal').style.display='none'">Bezárás</button>
        </div>
    </div>

    <div id="loginModal" class="modal-overlay">
        <div class="modal">
            <h3 style="margin-top:0; color:var(--text-color)">Bejelentkezés</h3>
            <input type="text" id="loginNameInput" placeholder="Felhasználónév...">
            <button onclick="performLogin()">Belépés</button>
            <button onclick="document.getElementById('loginModal').style.display='none'" style="background:transparent; margin-right:10px; color:var(--text-color)">Mégse</button>
        </div>
    </div>

    <script>
        // --- KONFIGURÁCIÓ ---
        const CLIENT_ID = '138100233309-v575n23j2b6pdek9t9clvkg3immlkrdi.apps.googleusercontent.com'; 
        const API_KEY = 'AIzaSyAfC2viqoOsVVjcShnqY2rrRsxdV7WHMEg'; 
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';

        // --- PEER CONFIG ---
        const peerConfig = {
            debug: 1,
            config: {
                'iceServers': [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: "turn:openrelay.metered.ca:80", username: "openrelayproject", credential: "openrelayproject" },
                    { urls: "turn:openrelay.metered.ca:443", username: "openrelayproject", credential: "openrelayproject" },
                    { urls: "turn:openrelay.metered.ca:443?transport=tcp", username: "openrelayproject", credential: "openrelayproject" }
                ]
            }
        };

        // --- GLOBÁLIS VÁLTOZÓK ---
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const bgLayer = document.getElementById('background-layer');
        const bgCtx = bgLayer.getContext('2d');
        const previewLayer = document.getElementById('preview-layer');
        const previewCtx = previewLayer.getContext('2d');
        const onionLayer = document.getElementById('onion-layer');
        const onionCtx = onionLayer.getContext('2d');
        
        let layers = [];
        let activeLayerId = null;
        let layerCounter = 1;
        
        let isDrawing = false;
        let startX = 0, startY = 0; 
        let lastX = 0, lastY = 0;
        let currentTool = 'brush'; 
        let penColor = '#ffffff';
        let penWidth = 5;
        let canvasBgColor = '#000000';

        // --- KIJELÖLÉS & VÁGÓLAP ---
        let selectionObj = null; // { canvas: offscreenCanvas, x, y, width, height, rotation }
        let isSelectionActive = false;
        let selectionPath = []; // Lasso path pontok
        let transformMode = null; // 'move', 'resize', 'rotate'
        let transformStartData = {}; // Segédváltozó transzformációhoz
        let appClipboard = null; // Belső vágólap (Ctrl+C/V)

        // --- ANIMÁCIÓS VÁLTOZÓK ---
        let isAnimationMode = false;
        let frames = [];
        let currentFrameIndex = 0;
        let isOnionSkin = true;
        let isPlaying = false;
        let playbackInterval = null;

        // --- UNDO / REDO ---
        const MAX_HISTORY = 30; 
        let undoStack = [];
        let redoStack = [];

        function saveStateForUndo() {
            if (!activeLayerId) return;
            const activeLayer = layers.find(l => l.id === activeLayerId);
            if (!activeLayer) return;

            // Ha van aktív kijelölés, azt süssük rá mielőtt mentünk, vagy mentsük a kijelölés előtti állapotot.
            // Egyszerűsítés: Ha rajzolunk, a kijelölés már rákerült vagy megszűnt.
            
            const currentState = {
                layerId: activeLayerId,
                imageData: activeLayer.ctx.getImageData(0, 0, activeLayer.canvas.width, activeLayer.canvas.height)
            };
            undoStack.push(currentState);
            if (undoStack.length > MAX_HISTORY) undoStack.shift();
            redoStack = [];
            updateUndoRedoButtons();
        }

        function undoLastAction() {
            // Ha van aktív kijelölés, az Undo először megszünteti azt (commit nélkül)
            if (isSelectionActive) {
                commitSelection(); // Vagy eldobás? Legyen inkább eldobás visszavonásnál.
                // De most egyszerűsítsünk: Undo visszateszi a képet az előző állapotra.
            }

            if (undoStack.length === 0) return;
            const previousState = undoStack.pop();
            const targetLayer = layers.find(l => l.id === previousState.layerId);

            if (targetLayer) {
                const redoState = {
                    layerId: previousState.layerId,
                    imageData: targetLayer.ctx.getImageData(0, 0, targetLayer.canvas.width, targetLayer.canvas.height)
                };
                redoStack.push(redoState);
                targetLayer.ctx.putImageData(previousState.imageData, 0, 0);
            }
            updateUndoRedoButtons();
            if(isAnimationMode) saveFrameToMemory(currentFrameIndex);
        }

        function redoLastAction() {
            if (redoStack.length === 0) return;
            const nextState = redoStack.pop();
            const targetLayer = layers.find(l => l.id === nextState.layerId);

            if (targetLayer) {
                const undoState = {
                    layerId: nextState.layerId,
                    imageData: targetLayer.ctx.getImageData(0, 0, targetLayer.canvas.width, targetLayer.canvas.height)
                };
                undoStack.push(undoState);
                targetLayer.ctx.putImageData(nextState.imageData, 0, 0);
            }
            updateUndoRedoButtons();
            if(isAnimationMode) saveFrameToMemory(currentFrameIndex);
        }

        function updateUndoRedoButtons() {
            document.getElementById('btn-undo').disabled = undoStack.length === 0;
            document.getElementById('btn-redo').disabled = redoStack.length === 0;
        }

        // --- RÉTEGKEZELÉS ---
        function initLayers() {
            addNewLayer("Réteg 1");
            resizeCanvases();
            updateUndoRedoButtons(); 
        }

        function createLayerCanvas(id) {
            const cvs = document.createElement('canvas');
            cvs.id = `layer-${id}`;
            cvs.className = 'drawing-layer';
            return cvs;
        }
        
        canvasWrapper.addEventListener('mousedown', startDraw);
        canvasWrapper.addEventListener('mousemove', draw);
        canvasWrapper.addEventListener('mouseup', stopDraw);
        canvasWrapper.addEventListener('mouseout', stopDraw); // stop selection drag
        canvasWrapper.addEventListener('touchstart', (e) => { e.preventDefault(); startDraw(new MouseEvent('mousedown', { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
        canvasWrapper.addEventListener('touchmove', (e) => { e.preventDefault(); draw(new MouseEvent('mousemove', { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY })); });
        canvasWrapper.addEventListener('touchend', (e) => { stopDraw(new MouseEvent('mouseup', { clientX: e.changedTouches[0]?.clientX, clientY: e.changedTouches[0]?.clientY })); });

        // Billentyűfigyelés (Ctrl+C, Ctrl+V, Enter, Esc)
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (isSelectionActive) commitSelection();
            }
            if (e.key === 'Escape') {
                if (isSelectionActive) commitSelection(); // Vagy cancel? Most legyen commit.
            }
            if (e.ctrlKey && (e.key === 'c' || e.key === 'C')) {
                if (isSelectionActive && selectionObj) {
                    appClipboard = {
                        canvas: document.createElement('canvas'),
                        width: selectionObj.width,
                        height: selectionObj.height
                    };
                    appClipboard.canvas.width = selectionObj.width;
                    appClipboard.canvas.height = selectionObj.height;
                    appClipboard.canvas.getContext('2d').drawImage(selectionObj.canvas, 0, 0);
                    // Opcionális: Rendszervágólapra is tehetnénk blobként, de most maradjunk belsőnél.
                }
            }
            if (e.ctrlKey && (e.key === 'v' || e.key === 'V')) {
                if (appClipboard) {
                    if (isSelectionActive) commitSelection(); // Ha volt aktív, süssük rá
                    
                    // Új selection létrehozása a vágólapról, középre
                    const rect = canvasWrapper.getBoundingClientRect();
                    const centerX = canvasWrapper.offsetWidth / 2 - appClipboard.width / 2;
                    const centerY = canvasWrapper.offsetHeight / 2 - appClipboard.height / 2;

                    selectionObj = {
                        canvas: document.createElement('canvas'),
                        x: centerX,
                        y: centerY,
                        width: appClipboard.width,
                        height: appClipboard.height,
                        rotation: 0
                    };
                    selectionObj.canvas.width = appClipboard.width;
                    selectionObj.canvas.height = appClipboard.height;
                    selectionObj.canvas.getContext('2d').drawImage(appClipboard.canvas, 0, 0);
                    
                    isSelectionActive = true;
                    setTool('select'); // Váltsunk kijelölőre, hogy mozgatható legyen
                    renderSelection();
                }
            }
        });

        function addNewLayer(nameOverride) {
            const id = layerCounter++;
            const name = nameOverride || `Réteg ${id}`;
            const newCanvas = createLayerCanvas(id);
            canvasWrapper.insertBefore(newCanvas, previewLayer);
            
            const layerObj = { id: id, canvas: newCanvas, ctx: newCanvas.getContext('2d', {willReadFrequently: true}), name: name };
            layers.push(layerObj);
            setActiveLayer(id);
            updateLayerListUI();
            resizeCanvases(); 
            if(isHost) broadcastLayerStructure(); 
        }

        function deleteLayer(id) {
            if(layers.length <= 1) { alert("Legalább egy rétegnek maradnia kell!"); return; }
            const index = layers.findIndex(l => l.id === id);
            if(index > -1) {
                undoStack = undoStack.filter(state => state.layerId !== id);
                redoStack = redoStack.filter(state => state.layerId !== id);
                updateUndoRedoButtons();

                canvasWrapper.removeChild(layers[index].canvas);
                layers.splice(index, 1);
                if(id === activeLayerId) {
                    setActiveLayer(layers[Math.max(0, index - 1)].id);
                }
                updateLayerListUI();
                if(isHost) broadcastLayerStructure(); 
            }
        }

        function setActiveLayer(id) {
            if (isSelectionActive) commitSelection(); // Ha réteget váltunk, véglegesítsük a kijelölést az előzőn (vagy az újon)
            activeLayerId = id;
            layers.forEach(l => {
                if(l.id === id) {
                    l.canvas.classList.add('active');
                } else {
                    l.canvas.classList.remove('active');
                }
            });
            updateLayerListUI();
        }

        function updateLayerListUI() {
            const container = document.getElementById('layer-list-container');
            container.innerHTML = "";
            layers.forEach(layer => {
                const item = document.createElement('div');
                item.className = `layer-item ${layer.id === activeLayerId ? 'active' : ''}`;
                item.onclick = () => setActiveLayer(layer.id);
                item.innerHTML = `
                    <span class="material-icons" style="font-size:16px; opacity:0.7;">layers</span>
                    <span class="layer-name">${layer.name}</span>
                    <div class="layer-actions">
                        <button onclick="event.stopPropagation(); deleteLayer(${layer.id})" title="Törlés">✕</button>
                    </div>
                `;
                container.appendChild(item);
            });
        }

        function clearCurrentLayer() {
            const activeLayer = layers.find(l => l.id === activeLayerId);
            if(activeLayer) {
                saveStateForUndo();
                activeLayer.ctx.clearRect(0, 0, activeLayer.canvas.width, activeLayer.canvas.height);
                broadcastDrawEvent({ type: 'clear_layer', layerId: activeLayerId });
                if(isAnimationMode) saveFrameToMemory(currentFrameIndex);
            }
        }

        function changeCanvasBg(color) {
            canvasBgColor = color;
            bgCtx.fillStyle = color;
            bgCtx.fillRect(0, 0, bgLayer.width, bgLayer.height);
            document.getElementById('canvas-bg-picker').value = color;
            if(isHost || (conn && conn.open)) broadcastDrawEvent({ type: 'bg_change', color: color });
        }

        // --- RAJZOLÓ LOGIKA ---
        function resizeCanvases() {
            let width, height;
            if (isAnimationMode) {
                const rect = canvasWrapper.getBoundingClientRect();
                width = rect.width;
                height = rect.height;
            } else {
                width = canvasWrapper.offsetWidth;
                height = canvasWrapper.offsetHeight;
            }
            
            function resizeCtx(ctx, cvs) {
                const tempCvs = document.createElement('canvas'); 
                tempCvs.width = cvs.width; tempCvs.height = cvs.height; 
                tempCvs.getContext('2d').drawImage(cvs,0,0);
                cvs.width = width; cvs.height = height;
                ctx.drawImage(tempCvs, 0, 0);
            }

            bgLayer.width = width; bgLayer.height = height;
            changeCanvasBg(canvasBgColor);

            previewLayer.width = width; previewLayer.height = height;
            onionLayer.width = width; onionLayer.height = height;

            layers.forEach(layer => {
                resizeCtx(layer.ctx, layer.canvas);
            });
            
            undoStack = []; redoStack = []; updateUndoRedoButtons();
        }
        window.addEventListener('resize', () => setTimeout(resizeCanvases, 100));

        function startDraw(e) {
            if(!activeLayerId) return;
            const rect = canvasWrapper.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // KIJELÖLÉS KEZELÉSE (Transzformáció)
            if (currentTool === 'select' && isSelectionActive && selectionObj) {
                // Ellenőrizzük, hogy transzformációs ponton vagyunk-e
                const handleSize = 10;
                // Forgatás fogantyú (felül középen, kicsit kijjebb)
                // Egyszerűsítés: koordinátarendszer forgatása miatt a hit-test is trükkös.
                // Most egyszerű doboz hit-testet használunk a képernyő koordinátákon.
                
                // Középpont
                const cx = selectionObj.x + selectionObj.width/2;
                const cy = selectionObj.y + selectionObj.height/2;
                
                // Egyszerű távolság alapú hit test a forgatóponthoz
                // A forgató pont a doboz felett van. Ha elforgatjuk, a pont is elfordul.
                const rotRad = selectionObj.rotation;
                const topHandleDist = selectionObj.height/2 + 20;
                const rotHandleX = cx + Math.sin(rotRad) * topHandleDist; // Ez a matek most csak kb. jó
                const rotHandleY = cy - Math.cos(rotRad) * topHandleDist;
                
                if (Math.hypot(x - rotHandleX, y - rotHandleY) < 15) {
                    isDrawing = true;
                    transformMode = 'rotate';
                    transformStartData = { startAngle: Math.atan2(y - cy, x - cx), originalRot: selectionObj.rotation };
                    return;
                }
                
                // Méretezés (jobb alsó sarok, elforgatva)
                // A sarok pontok kiszámítása transzformációval:
                // Túl bonyolult lenne itt a pontos OBB (Oriented Bounding Box) hit test minden sarokra.
                // Egyszerűsítés: Ha a doboz belsejében kattint: Mozgatás.
                
                // Transzformáljuk vissza az egeret a doboz lokális koordinátáiba
                const dx = x - cx;
                const dy = y - cy;
                const localX = dx * Math.cos(-rotRad) - dy * Math.sin(-rotRad);
                const localY = dx * Math.sin(-rotRad) + dy * Math.cos(-rotRad);
                
                const halfW = selectionObj.width / 2;
                const halfH = selectionObj.height / 2;

                if (localX > halfW - 15 && localX < halfW + 15 && localY > halfH - 15 && localY < halfH + 15) {
                     isDrawing = true;
                     transformMode = 'resize';
                     transformStartData = { startX: x, startY: y, startW: selectionObj.width, startH: selectionObj.height };
                     return;
                }

                if (localX >= -halfW && localX <= halfW && localY >= -halfH && localY <= halfH) {
                    isDrawing = true;
                    transformMode = 'move';
                    transformStartData = { startX: x, startY: y, objX: selectionObj.x, objY: selectionObj.y };
                    return;
                }

                // Ha kívül kattint, commitoljuk a kijelölést és kezdjünk újat (ha select tool)
                commitSelection();
            }

            // Ha Select tool, de nincs aktív, kezdjük a lasso-t
            if (currentTool === 'select' && !isSelectionActive) {
                isDrawing = true;
                selectionPath = [{x, y}];
                previewCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
                previewCtx.beginPath();
                previewCtx.moveTo(x, y);
                return;
            }

            // Egyéb eszközök
            if (currentTool === 'fill') {
                if (isSelectionActive) commitSelection(); // Ha rajzolunk, süssük rá a kijelölést
                saveStateForUndo();
                const activeLayer = layers.find(l => l.id === activeLayerId);
                if (activeLayer) {
                    floodFill(activeLayer.ctx, Math.floor(x), Math.floor(y), penColor);
                    if(isHost || (conn && conn.open)) {
                          broadcastDrawEvent({ type: 'fill', layerId: activeLayerId, x: Math.floor(x), y: Math.floor(y), color: penColor });
                    }
                    if(isAnimationMode) saveFrameToMemory(currentFrameIndex);
                }
                return; 
            }

            if (isSelectionActive) commitSelection(); // Bármi más rajzolásnál commit

            isDrawing = true;
            startX = x; startY = y;
            [lastX, lastY] = [x, y];
            saveStateForUndo();
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = canvasWrapper.getBoundingClientRect();
            const newX = e.clientX - rect.left;
            const newY = e.clientY - rect.top;

            // KIJELÖLÉS TRANSZFORMÁCIÓ
            if (currentTool === 'select' && isSelectionActive && selectionObj) {
                if (transformMode === 'move') {
                    const dx = newX - transformStartData.startX;
                    const dy = newY - transformStartData.startY;
                    selectionObj.x = transformStartData.objX + dx;
                    selectionObj.y = transformStartData.objY + dy;
                } else if (transformMode === 'resize') {
                    // Egyszerű méretezés (aránytartás nélkül most)
                    // Az egér távolsága a középponttól a méretet határozza meg
                    const cx = selectionObj.x + selectionObj.width/2;
                    const cy = selectionObj.y + selectionObj.height/2;
                    // Visszaforgatott koordináták
                    const dx = newX - cx;
                    const dy = newY - cy;
                    const rot = -selectionObj.rotation;
                    const localX = dx * Math.cos(rot) - dy * Math.sin(rot);
                    const localY = dx * Math.sin(rot) + dy * Math.cos(rot);
                    
                    // Új szélesség/magasság (min 10px)
                    selectionObj.width = Math.max(10, localX * 2);
                    selectionObj.height = Math.max(10, localY * 2);
                    // Kompenzálni kell az x,y pozíciót, mert a méret változás a bal felső sarokból indulna
                    selectionObj.x = cx - selectionObj.width/2;
                    selectionObj.y = cy - selectionObj.height/2;

                } else if (transformMode === 'rotate') {
                    const cx = selectionObj.x + selectionObj.width/2;
                    const cy = selectionObj.y + selectionObj.height/2;
                    const currentAngle = Math.atan2(newY - cy, newX - cx);
                    const angleDiff = currentAngle - transformStartData.startAngle;
                    selectionObj.rotation = transformStartData.originalRot + angleDiff;
                }
                renderSelection();
                return;
            }

            // KIJELÖLÉS RAJZOLÁS (LASSO)
            if (currentTool === 'select' && !isSelectionActive) {
                selectionPath.push({x: newX, y: newY});
                previewCtx.lineTo(newX, newY);
                previewCtx.strokeStyle = '#00ffcc';
                previewCtx.lineWidth = 1;
                previewCtx.setLineDash([5, 5]);
                previewCtx.stroke();
                return;
            }
            
            // NORMÁL RAJZOLÁS
            const activeLayer = layers.find(l => l.id === activeLayerId);
            if(!activeLayer) return;

            let colorToUse = penColor;
            let isEraser = currentTool === 'eraser';
            if (isEraser) colorToUse = 'rgba(0,0,0,1)';

            if (currentTool === 'brush' || currentTool === 'eraser') {
                drawLine(activeLayer.ctx, lastX, lastY, newX, newY, colorToUse, penWidth, isEraser);
                broadcastDrawEvent({ type: 'draw', layerId: activeLayerId, x0: lastX, y0: lastY, x1: newX, y1: newY, color: colorToUse, width: penWidth, isEraser: isEraser });
                [lastX, lastY] = [newX, newY];
            } 
            else if (['rect', 'circle', 'hexagon', 'line'].includes(currentTool)) {
                previewCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
                drawShape(previewCtx, startX, startY, newX, newY, currentTool, penColor, penWidth);
            }
        }

        function stopDraw(e) { 
            if (!isDrawing) return;
            isDrawing = false;
            
            // KIJELÖLÉS VÉGE (Lasso befejezése -> Kivágás)
            if (currentTool === 'select' && !isSelectionActive && selectionPath.length > 2) {
                createSelectionFromPath();
                previewCtx.setLineDash([]);
                return;
            }

            // Transzformáció vége
            if (currentTool === 'select' && isSelectionActive) {
                transformMode = null;
                return;
            }

            if (['rect', 'circle', 'hexagon', 'line'].includes(currentTool)) {
                const rect = canvasWrapper.getBoundingClientRect();
                let endX = lastX;
                let endY = lastY;
                if(e.clientX) { endX = e.clientX - rect.left; endY = e.clientY - rect.top; }

                const activeLayer = layers.find(l => l.id === activeLayerId);
                if(activeLayer) {
                    drawShape(activeLayer.ctx, startX, startY, endX, endY, currentTool, penColor, penWidth);
                    previewCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
                    if(isHost || (conn && conn.open)) {
                        broadcastDrawEvent({ type: 'shape', tool: currentTool, x0: startX, y0: startY, x1: endX, y1: endY, color: penColor, width: penWidth, layerId: activeLayerId });
                    }
                }
            }
            if(isAnimationMode) saveFrameToMemory(currentFrameIndex);
        }

        // --- SELECTION LOGIC ---

        function createSelectionFromPath() {
            const activeLayer = layers.find(l => l.id === activeLayerId);
            if (!activeLayer) return;

            // 1. Bounding Box számítás
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            selectionPath.forEach(p => {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            });
            const w = maxX - minX;
            const h = maxY - minY;
            if (w <= 0 || h <= 0) return;

            // 2. Offscreen canvas létrehozása a kivágott tartalomnak
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tCtx = tempCanvas.getContext('2d');

            // 3. Kivágás: Először a path-t használjuk clipping mask-ként
            tCtx.beginPath();
            tCtx.moveTo(selectionPath[0].x - minX, selectionPath[0].y - minY);
            for (let i = 1; i < selectionPath.length; i++) {
                tCtx.lineTo(selectionPath[i].x - minX, selectionPath[i].y - minY);
            }
            tCtx.closePath();
            tCtx.clip();
            
            // Rárajzoljuk az eredeti képet (eltolva, hogy a boxba essen)
            tCtx.drawImage(activeLayer.canvas, -minX, -minY);

            // 4. Eredeti helyről törlés (Clear)
            activeLayer.ctx.save();
            activeLayer.ctx.beginPath();
            activeLayer.ctx.moveTo(selectionPath[0].x, selectionPath[0].y);
            for (let i = 1; i < selectionPath.length; i++) {
                activeLayer.ctx.lineTo(selectionPath[i].x, selectionPath[i].y);
            }
            activeLayer.ctx.closePath();
            activeLayer.ctx.clip();
            activeLayer.ctx.clearRect(0, 0, activeLayer.canvas.width, activeLayer.canvas.height);
            activeLayer.ctx.restore();

            // 5. Selection Object mentése
            selectionObj = {
                canvas: tempCanvas,
                x: minX,
                y: minY,
                width: w,
                height: h,
                rotation: 0
            };
            isSelectionActive = true;
            selectionPath = []; // Path már nem kell

            // Törlés esemény küldése (hogy másoknál is eltűnjön az eredeti helyről)
            // Megjegyzés: Ez nem tökéletes, mert a clipping path bonyolult hálózaton.
            // Egyszerűsítés: Most nem szinkronizáljuk a "lyukat" azonnal, csak amikor visszasütjük a képet.
            // Vagy: P2P-ben "Select" eszköz csak lokális, amíg Entert nem nyomsz.

            renderSelection();
        }

        function renderSelection() {
            if (!selectionObj) return;
            previewCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);

            previewCtx.save();
            
            // Középpontba transzformálás
            const cx = selectionObj.x + selectionObj.width / 2;
            const cy = selectionObj.y + selectionObj.height / 2;
            
            previewCtx.translate(cx, cy);
            previewCtx.rotate(selectionObj.rotation);
            
            // Kép kirajzolása (méretezve is)
            previewCtx.drawImage(selectionObj.canvas, -selectionObj.width/2, -selectionObj.height/2, selectionObj.width, selectionObj.height);

            // Keret rajzolása
            previewCtx.strokeStyle = 'var(--selection-color)'; // Zöldes keret
            previewCtx.lineWidth = 1;
            previewCtx.setLineDash([5, 3]);
            previewCtx.strokeRect(-selectionObj.width/2, -selectionObj.height/2, selectionObj.width, selectionObj.height);

            // Fogantyúk
            previewCtx.setLineDash([]);
            previewCtx.fillStyle = 'white';
            previewCtx.strokeStyle = 'black';
            
            // Resize (jobb alsó)
            previewCtx.beginPath();
            previewCtx.rect(selectionObj.width/2 - 5, selectionObj.height/2 - 5, 10, 10);
            previewCtx.fill();
            previewCtx.stroke();

            // Rotate (fent középen, kiemelve)
            previewCtx.beginPath();
            previewCtx.moveTo(0, -selectionObj.height/2);
            previewCtx.lineTo(0, -selectionObj.height/2 - 20);
            previewCtx.stroke();
            previewCtx.beginPath();
            previewCtx.arc(0, -selectionObj.height/2 - 20, 5, 0, Math.PI * 2);
            previewCtx.fill();
            previewCtx.stroke();

            previewCtx.restore();
        }

        function commitSelection() {
            if (!isSelectionActive || !selectionObj) return;

            const activeLayer = layers.find(l => l.id === activeLayerId);
            if (activeLayer) {
                activeLayer.ctx.save();
                
                const cx = selectionObj.x + selectionObj.width / 2;
                const cy = selectionObj.y + selectionObj.height / 2;
                
                activeLayer.ctx.translate(cx, cy);
                activeLayer.ctx.rotate(selectionObj.rotation);
                activeLayer.ctx.drawImage(selectionObj.canvas, -selectionObj.width/2, -selectionObj.height/2, selectionObj.width, selectionObj.height);
                activeLayer.ctx.restore();

                // P2P Szinkronizáció: Mivel a transzformáció bonyolult, elküldjük a végeredményt képként (snapshot-szerűen) 
                // vagy "drawImage" parancsként.
                if (isHost || (conn && conn.open)) {
                     // Elküldjük a beillesztést drawImage parancsként. 
                     // Ehhez konvertáljuk dataURL-re a kis canvas-t
                     const imgDataUrl = selectionObj.canvas.toDataURL();
                     broadcastDrawEvent({
                         type: 'paste_image',
                         layerId: activeLayerId,
                         image: imgDataUrl,
                         x: cx, y: cy, w: selectionObj.width, h: selectionObj.height, r: selectionObj.rotation
                     });
                }
            }

            // Takarítás
            previewCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
            selectionObj = null;
            isSelectionActive = false;
            if(isAnimationMode) saveFrameToMemory(currentFrameIndex);
        }

        // --- HELPER FUNCTIONS ---
        function drawLine(targetCtx, x0, y0, x1, y1, color, width, isEraser) {
            targetCtx.beginPath(); targetCtx.moveTo(x0, y0); targetCtx.lineTo(x1, y1);
            targetCtx.strokeStyle = color; targetCtx.lineWidth = width;
            targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round';
            if(isEraser) targetCtx.globalCompositeOperation = 'destination-out';
            targetCtx.stroke();
            targetCtx.closePath();
            if(isEraser) targetCtx.globalCompositeOperation = 'source-over';
        }

        function drawShape(ctx, x0, y0, x1, y1, type, color, width) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            const w = x1 - x0;
            const h = y1 - y0;
            const centerX = x0 + w/2;
            const centerY = y0 + h/2;

            if (type === 'line') {
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
            } else if (type === 'rect') {
                ctx.rect(x0, y0, w, h);
            } else if (type === 'circle') {
                const radiusX = Math.abs(w/2);
                const radiusY = Math.abs(h/2);
                ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            } else if (type === 'hexagon') {
                const sides = 6;
                const radiusX = w/2;
                const radiusY = h/2;
                for (let i = 0; i < sides; i++) {
                    const angle = (i * 2 * Math.PI / sides) - Math.PI / 2;
                    const x = centerX + radiusX * Math.cos(angle);
                    const y = centerY + radiusY * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
            }
            ctx.stroke();
        }

        // --- FLOOD FILL ---
        function floodFill(ctx, startX, startY, fillColorHex) {
            const r = parseInt(fillColorHex.slice(1, 3), 16);
            const g = parseInt(fillColorHex.slice(3, 5), 16);
            const b = parseInt(fillColorHex.slice(5, 7), 16);
            const a = 255;
            
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            if(startX < 0 || startY < 0 || startX >= w || startY >= h) return;

            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;
            const startPos = (startY * w + startX) * 4;
            
            const startR = data[startPos];
            const startG = data[startPos + 1];
            const startB = data[startPos + 2];
            const startA = data[startPos + 3];

            if (startR === r && startG === g && startB === b && startA === a) return;

            const stack = [[startX, startY]];
            
            while (stack.length) {
                const [x, y] = stack.pop();
                const pos = (y * w + x) * 4;

                if (data[pos] === startR && data[pos+1] === startG && data[pos+2] === startB && data[pos+3] === startA) {
                    data[pos] = r;
                    data[pos+1] = g;
                    data[pos+2] = b;
                    data[pos+3] = a;

                    if (x > 0) stack.push([x - 1, y]);
                    if (x < w - 1) stack.push([x + 1, y]);
                    if (y > 0) stack.push([x, y - 1]);
                    if (y < h - 1) stack.push([x, y + 1]);
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }

        // --- ANIMÁCIÓS LOGIKA ---
        function toggleAnimationMode() {
            if(isSelectionActive) commitSelection(); // Animáció előtt commit
            isAnimationMode = !isAnimationMode;
            const btn = document.getElementById('btn-anim-toggle');
            const panel = document.getElementById('animation-panel');
            const layerPanel = document.querySelector('.layer-panel-right');

            if (isAnimationMode) {
                btn.classList.add('active-mode');
                canvasWrapper.classList.add('square-mode');
                panel.classList.add('active');
                layerPanel.classList.add('hidden'); 
                initAnimation();
            } else {
                stopAnimation();
                btn.classList.remove('active-mode');
                canvasWrapper.classList.remove('square-mode');
                panel.classList.remove('active');
                layerPanel.classList.remove('hidden');
                onionCtx.clearRect(0,0,onionLayer.width, onionLayer.height);
                resizeCanvases();
            }
            setTimeout(resizeCanvases, 50); 
        }

        function initAnimation() {
            layers.forEach(l => { if(l.id !== activeLayerId) deleteLayer(l.id); }); 
            if(layers.length === 0) addNewLayer("FrameLayer");
            const activeLayer = layers[0];
            activeLayer.ctx.clearRect(0,0,activeLayer.canvas.width, activeLayer.canvas.height);
            
            frames = [];
            currentFrameIndex = 0;
            animAddFrame(true); 
            updateTimelineUI();
        }

        function animAddFrame(isInit = false) {
            if (!isInit) saveFrameToMemory(currentFrameIndex);
            const width = Math.floor(bgLayer.width);
            const height = Math.floor(bgLayer.height);
            const emptyData = new ImageData(width > 0 ? width : 100, height > 0 ? height : 100); 
            
            if (frames.length > 0) {
                 frames.splice(currentFrameIndex + 1, 0, { imageData: emptyData });
                 currentFrameIndex++;
            } else {
                frames.push({ imageData: emptyData });
                currentFrameIndex = 0;
            }

            const activeLayer = layers.find(l => l.id === activeLayerId);
            if(activeLayer) activeLayer.ctx.clearRect(0, 0, activeLayer.canvas.width, activeLayer.canvas.height);
            
            undoStack = []; redoStack = []; updateUndoRedoButtons();
            updateTimelineUI();
            updateOnionSkin();
        }

        function saveFrameToMemory(index) {
            const activeLayer = layers.find(l => l.id === activeLayerId);
            if(!activeLayer || !frames[index]) return;
            frames[index].imageData = activeLayer.ctx.getImageData(0, 0, activeLayer.canvas.width, activeLayer.canvas.height);
        }

        function loadFrameFromMemory(index) {
            const activeLayer = layers.find(l => l.id === activeLayerId);
            if(!activeLayer || !frames[index]) return;
            activeLayer.ctx.putImageData(frames[index].imageData, 0, 0);
            currentFrameIndex = index;
            updateTimelineUI();
            updateOnionSkin();
        }

        function animNextFrame() {
            if(isPlaying) return;
            saveFrameToMemory(currentFrameIndex);
            if (currentFrameIndex < frames.length - 1) {
                loadFrameFromMemory(currentFrameIndex + 1);
            }
        }

        function animPrevFrame() {
            if(isPlaying) return;
            saveFrameToMemory(currentFrameIndex);
            if (currentFrameIndex > 0) {
                loadFrameFromMemory(currentFrameIndex - 1);
            }
        }
        
        function animDeleteFrame() {
            if (frames.length <= 1) return;
            frames.splice(currentFrameIndex, 1);
            if (currentFrameIndex >= frames.length) currentFrameIndex = frames.length - 1;
            loadFrameFromMemory(currentFrameIndex);
        }

        function animToggleOnion() {
            isOnionSkin = !isOnionSkin;
            document.getElementById('onion-icon').style.opacity = isOnionSkin ? '1' : '0.4';
            updateOnionSkin();
        }

        function updateOnionSkin() {
            onionCtx.clearRect(0, 0, onionLayer.width, onionLayer.height);
            if (isPlaying || !isOnionSkin || currentFrameIndex === 0) return;

            const prevFrame = frames[currentFrameIndex - 1];
            if (prevFrame) {
                const tempCvs = document.createElement('canvas');
                tempCvs.width = onionLayer.width;
                tempCvs.height = onionLayer.height;
                tempCvs.getContext('2d').putImageData(prevFrame.imageData, 0, 0);
                onionCtx.globalAlpha = 0.3;
                onionCtx.drawImage(tempCvs, 0, 0);
                onionCtx.globalAlpha = 1.0;
            }
        }

        // --- ANIMÁCIÓ LEJÁTSZÁS ---
        function togglePlayAnimation() {
            if (isPlaying) {
                stopAnimation();
            } else {
                playAnimation();
            }
        }

        function playAnimation() {
            if (frames.length < 2) return;
            saveFrameToMemory(currentFrameIndex);
            isPlaying = true;
            document.getElementById('btn-play').innerHTML = '<span class="material-icons">stop</span> Stop';
            document.getElementById('btn-play').classList.add('playing');
            onionCtx.clearRect(0, 0, onionLayer.width, onionLayer.height);

            let playIndex = 0;
            const fps = parseInt(document.getElementById('fps-input').value) || 5;
            const intervalTime = 1000 / fps;

            playbackInterval = setInterval(() => {
                const activeLayer = layers.find(l => l.id === activeLayerId);
                if(activeLayer && frames[playIndex]) {
                    activeLayer.ctx.putImageData(frames[playIndex].imageData, 0, 0);
                    document.getElementById('frame-counter').innerText = `${playIndex + 1} / ${frames.length}`;
                }
                playIndex++;
                if (playIndex >= frames.length) playIndex = 0;
            }, intervalTime);
        }

        function stopAnimation() {
            isPlaying = false;
            clearInterval(playbackInterval);
            document.getElementById('btn-play').innerHTML = '<span class="material-icons">play_arrow</span> Lejátszás';
            document.getElementById('btn-play').classList.remove('playing');
            loadFrameFromMemory(currentFrameIndex);
        }

        function updateTimelineUI() {
            const container = document.getElementById('timeline-container');
            container.innerHTML = '';
            document.getElementById('frame-counter').innerText = `${currentFrameIndex + 1} / ${frames.length}`;

            frames.forEach((frame, idx) => {
                const div = document.createElement('div');
                div.className = `frame-thumb ${idx === currentFrameIndex ? 'active' : ''}`;
                div.onclick = () => { if(!isPlaying) { saveFrameToMemory(currentFrameIndex); loadFrameFromMemory(idx); } };
                
                const miniCvs = document.createElement('canvas');
                miniCvs.width = bgLayer.width; miniCvs.height = bgLayer.height;
                const ctx = miniCvs.getContext('2d');
                ctx.fillStyle = canvasBgColor; ctx.fillRect(0,0, miniCvs.width, miniCvs.height);
                ctx.putImageData(frame.imageData, 0, 0);
                
                div.appendChild(miniCvs);
                div.innerHTML += `<div class="frame-number">${idx + 1}</div>`;
                container.appendChild(div);
            });
            const activeThumb = container.children[currentFrameIndex];
            if(activeThumb) activeThumb.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }

        // --- GIF EXPORT ---
        async function renderGIF() {
            if(frames.length === 0) return;
            if(isPlaying) stopAnimation();
            saveFrameToMemory(currentFrameIndex);

            const overlay = document.getElementById('loading-overlay');
            overlay.style.display = 'flex';
            document.getElementById('loading-text').innerText = "GIF Generálása (Internet szükséges)...";

            try {
                const workerUrl = 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js';
                const response = await fetch(workerUrl);
                if (!response.ok) throw new Error("Nem sikerült letölteni a GIF generáló komponenst.");
                const workerScriptText = await response.text();
                const blob = new Blob([workerScriptText], { type: 'application/javascript' });
                const blobUrl = URL.createObjectURL(blob);

                const gif = new GIF({
                    workers: 2,
                    quality: 10,
                    width: bgLayer.width,
                    height: bgLayer.height,
                    workerScript: blobUrl
                });

                const fps = parseInt(document.getElementById('fps-input').value) || 5;
                const delay = 1000 / fps;

                frames.forEach(frame => {
                    const tempCvs = document.createElement('canvas');
                    tempCvs.width = bgLayer.width; tempCvs.height = bgLayer.height;
                    const ctx = tempCvs.getContext('2d');
                    ctx.fillStyle = canvasBgColor;
                    ctx.fillRect(0, 0, tempCvs.width, tempCvs.height);
                    ctx.putImageData(frame.imageData, 0, 0);
                    gif.addFrame(tempCvs, {delay: delay});
                });

                gif.on('finished', function(blob) {
                    overlay.style.display = 'none';
                    const link = document.createElement('a');
                    link.download = `AeroDraw_Anim_${Date.now()}.gif`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(blobUrl);
                });

                gif.render();

            } catch (err) {
                console.error(err);
                alert("Hiba a GIF generálásakor: " + err.message + "\nEllenőrizd az internetkapcsolatot!");
                overlay.style.display = 'none';
            }
        }

        // --- UI ESEMÉNYEK ---
        function pickColor(color, element) {
            penColor = color;
            document.getElementById('pen-color-input').value = color;
            document.querySelectorAll('.hex-swatch').forEach(el => el.classList.remove('active'));
            element.classList.add('active');
            if(currentTool === 'eraser') setTool('brush');
        }
        document.getElementById('pen-color-input').addEventListener('input', (e) => { penColor = e.target.value; document.querySelectorAll('.hex-swatch').forEach(el => el.classList.remove('active')); if(currentTool === 'eraser') setTool('brush'); });
        document.getElementById('pen-width').addEventListener('input', (e) => penWidth = e.target.value);
        function setTool(tool) { 
            if (isSelectionActive && tool !== 'select') commitSelection(); // Ha váltunk másra, commit
            currentTool = tool; 
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active')); 
            document.getElementById(`btn-${tool}`).classList.add('active'); 
        }

        function downloadImage() {
            if(isSelectionActive) commitSelection();
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = bgLayer.width; tempCanvas.height = bgLayer.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(bgLayer, 0, 0);
                layers.forEach(layer => { tempCtx.drawImage(layer.canvas, 0, 0); });
                
                const link = document.createElement('a');
                link.download = `AeroDraw_Pro_${new Date().getTime()}.png`;
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
            } catch (e) {
                alert("Hiba a kép mentésekor. Lehetséges ok: túl nagy vászon.");
            }
        }

        // --- AUTH & P2P ALAPOK ---
        let currentUser=null, tokenClient, gapiInited=false, gisInited=false;
        let peer=null, conn=null, isHost=false, connectedUsers=[], maxParticipants=3;
        const ROOM_MAPPING = {"1":"adp_v2_r1","2":"adp_v2_r2","3":"adp_v2_r3"};
        
        function openLoginModal() { document.getElementById('loginModal').style.display='flex'; }
        function performLogin() { const name=document.getElementById('loginNameInput').value.trim(); if(!name)return; localStorage.setItem('saved_user',name); currentUser=name; document.getElementById('user-btn').innerText=name; document.getElementById('loginModal').style.display='none'; document.getElementById('login-warning').style.display='none'; if(gapiInited&&gisInited&&!gapi.client.getToken())tokenClient.requestAccessToken({prompt:''}); }
        function gapiLoaded(){gapi.load('client',async()=>{await gapi.client.init({apiKey:API_KEY,discoveryDocs:[DISCOVERY_DOC]});gapiInited=true;});}
        function gisLoaded(){tokenClient=google.accounts.oauth2.initTokenClient({client_id:CLIENT_ID,scope:SCOPES,callback:(resp)=>{}});gisInited=true;}

        // --- P2P SZINKRONIZÁCIÓ ---
        function broadcastDrawEvent(data) {
            if(isHost) connectedUsers.forEach(u => u.conn.send(data));
            else if(conn && conn.open) conn.send(data);
        }

        function broadcastLayerStructure() {
            if(!isHost || isAnimationMode) return;
            const structure = layers.map(l => ({ id: l.id, name: l.name }));
            connectedUsers.forEach(u => u.conn.send({ type: 'layer_structure', layers: structure, bg: canvasBgColor }));
        }

        function sendFullSnapshot(targetConn) {
            const snapshot = { type: 'full_snapshot', bg: canvasBgColor, layers: [] };
            layers.forEach(l => {
                snapshot.layers.push({ id: l.id, image: l.canvas.toDataURL() });
            });
            targetConn.send(snapshot);
        }

        function handleP2PData(data) {
            if (data.type === 'draw') {
                const targetLayer = layers.find(l => l.id === data.layerId);
                if(targetLayer) drawLine(targetLayer.ctx, data.x0, data.y0, data.x1, data.y1, data.color, data.width, data.isEraser);
            }
            else if (data.type === 'shape') {
                const targetLayer = layers.find(l => l.id === data.layerId);
                if(targetLayer) drawShape(targetLayer.ctx, data.x0, data.y0, data.x1, data.y1, data.tool, data.color, data.width);
            }
            else if (data.type === 'fill') {
                const targetLayer = layers.find(l => l.id === data.layerId);
                if(targetLayer) floodFill(targetLayer.ctx, data.x, data.y, data.color);
            }
            else if (data.type === 'paste_image') {
                const targetLayer = layers.find(l => l.id === data.layerId);
                if (targetLayer) {
                    const img = new Image();
                    img.onload = () => {
                        targetLayer.ctx.save();
                        targetLayer.ctx.translate(data.x, data.y);
                        targetLayer.ctx.rotate(data.r);
                        targetLayer.ctx.drawImage(img, -data.w/2, -data.h/2, data.w, data.h);
                        targetLayer.ctx.restore();
                    };
                    img.src = data.image;
                }
            }
            else if(data.type === 'clear_layer') {
                const targetLayer = layers.find(l => l.id === data.layerId);
                if(targetLayer) targetLayer.ctx.clearRect(0,0,targetLayer.canvas.width, targetLayer.canvas.height);
            }
            else if(data.type === 'bg_change') { changeCanvasBg(data.color); }
            else if(data.type === 'layer_structure') {
                if(isAnimationMode) return;
                canvasWrapper.innerHTML = '<canvas id="background-layer" class="drawing-layer"></canvas><canvas id="onion-layer" class="drawing-layer"></canvas><canvas id="preview-layer" class="drawing-layer"></canvas>'; 
                const newBg = document.getElementById('background-layer'); bgCtx = newBg.getContext('2d');
                layers = []; undoStack = []; redoStack = []; updateUndoRedoButtons();
                changeCanvasBg(data.bg);
                data.layers.forEach(lData => {
                    const newCanvas = createLayerCanvas(lData.id);
                    canvasWrapper.insertBefore(newCanvas, previewLayer);
                    layers.push({ id: lData.id, canvas: newCanvas, ctx: newCanvas.getContext('2d'), name: lData.name });
                });
                resizeCanvases();
                if(layers.length > 0) setActiveLayer(layers[0].id);
            }
            else if(data.type === 'full_snapshot') {
                changeCanvasBg(data.bg);
                data.layers.forEach(lData => {
                    const targetLayer = layers.find(l => l.id === lData.id);
                    if(targetLayer) {
                        const img = new Image(); img.onload = () => targetLayer.ctx.drawImage(img, 0, 0); img.src = lData.image;
                    }
                });
            }
            else if(data.type==='user_list') { connectedUsers=data.users; updateActiveUsersUI(); }
            else if(data.type==='kick') { alert("Kirúgtak."); disconnectPeer(); }
        }

        // --- P2P CORE ---
        function startAsHost() { 
            if(!currentUser){openLoginModal();return;} 
            if(peer)return; 
            isHost=true; connectedUsers=[]; maxParticipants=parseInt(document.getElementById('room-size-limit').value)||3; 
            peer=new Peer(ROOM_MAPPING[document.getElementById('channel-select').value], peerConfig); 
            peer.on('open',id=>{document.getElementById('live-indicator').style.display='block';updateP2PUI(true);}); 
            peer.on('connection',c=>{if(connectedUsers.length+1>=maxParticipants){c.on('open',()=>{c.send({type:'error',message:'Tele'});setTimeout(()=>c.close(),500);});return;} c.on('data',d=>{if(d.type==='handshake'){connectedUsers.push({id:c.peer,conn:c,username:d.username}); broadcastUserList(); sendFullSnapshot(c); } else handleP2PData(d);}); c.on('close',()=>{connectedUsers=connectedUsers.filter(u=>u.id!==c.peer);broadcastUserList();updateActiveUsersUI();});}); 
        }

        function joinAsGuest() { 
            if(!currentUser){openLoginModal();return;} 
            if(peer)return; 
            isHost=false; 
            peer=new Peer(null, peerConfig); 
            peer.on('open',()=>{conn=peer.connect(ROOM_MAPPING[document.getElementById('channel-select').value]); conn.on('open',()=>{conn.send({type:'handshake',username:currentUser}); document.getElementById('live-indicator').style.display='block';updateP2PUI(true);}); conn.on('data',handleP2PData); conn.on('close',resetP2PUI);}); 
        }

        function broadcastUserList(){if(!isHost)return; const list=connectedUsers.map(u=>({id:u.id,username:u.username})); list.unshift({id:'HOST',username:currentUser+' (HOST)'}); connectedUsers.forEach(u=>u.conn.send({type:'user_list',users:list})); updateActiveUsersUI();}
        function updateActiveUsersUI(){const c=document.getElementById('active-users-list'); c.innerHTML=`<div class="user-chip self"><span class="username">${currentUser}</span></div>`; connectedUsers.forEach(u=>{c.innerHTML+=`<div class="user-chip"><span class="username">${u.username}</span>${isHost?`<button class="kick-btn" onclick="kickUser('${u.id}')">x</button>`:''}</div>`});}
        function kickUser(id){const u=connectedUsers.find(x=>x.id===id);if(u){u.conn.send({type:'kick'});setTimeout(()=>u.conn.close(),100);}}
        function disconnectPeer(){if(isHost)connectedUsers.forEach(u=>u.conn.close());if(conn)conn.close();if(peer)peer.destroy();resetP2PUI();}
        function resetP2PUI(){peer=null;conn=null;isHost=false;connectedUsers=[];document.getElementById('live-indicator').style.display='none';updateP2PUI(false);}
        function updateP2PUI(online){document.getElementById('connect-ui').style.display=online?'none':'block';document.getElementById('disconnect-ui').style.display=online?'block':'none';document.getElementById('p2p-log').innerText=online?(isHost?"HOST ONLINE":"ONLINE"):"Offline";document.getElementById('p2p-log').style.color=online?"#50fa7b":"#888";}

        // --- DRIVE SAVE ---
        async function handleDriveSave() { 
            if(isSelectionActive) commitSelection();
            document.getElementById('loading-overlay').style.display='flex'; document.getElementById('loading-text').innerText="Felhő mentés..."; if(!currentUser||!gapi.client.getToken()){alert("Jelentkezz be!");document.getElementById('loading-overlay').style.display='none';return;}
            const tempCanvas=document.createElement('canvas'); tempCanvas.width=bgLayer.width; tempCanvas.height=bgLayer.height; const ctx=tempCanvas.getContext('2d'); ctx.drawImage(bgLayer,0,0); layers.forEach(l=>ctx.drawImage(l.canvas,0,0));
            tempCanvas.toBlob(async blob=>{ const meta={'name':`AeroDraw_${currentUser}_${Date.now()}.png`,'mimeType':'image/png'}; const form=new FormData(); form.append('metadata',new Blob([JSON.stringify(meta)],{type:'application/json'})); form.append('file',blob);
            try{await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',{method:'POST',headers:new Headers({'Authorization':'Bearer '+gapi.client.getToken().access_token}),body:form});alert("Mentve!");}catch(e){alert("Hiba!");} document.getElementById('loading-overlay').style.display='none'; }); }

        // UI & Egyéb
        let isDark=true; function toggleTheme(){isDark=!isDark;document.body.className=isDark?"":"light-mode";}
        function openSettings(){document.getElementById('settingsModal').style.display='flex';}
        
        const savedUser = localStorage.getItem('saved_user'); if(savedUser){currentUser=savedUser;document.getElementById('user-btn').innerText=savedUser;}
        setTimeout(initLayers, 100); 
    </script>
</body>
</html>
