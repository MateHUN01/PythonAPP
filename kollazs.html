<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AeroCollage PRO - P2P Collage Maker</title>
    
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <style>
        :root {
            --bg-color: #121212;
            --workspace-bg: #1a1a1a;
            --text-color: #e0e0e0;
            --accent-color: #2196F3;
            --border-color: #333;
            
            /* Glassmorphism */
            --glass-bg: rgba(20, 20, 20, 0.7);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.8);
            --glass-blur: 15px;

            --btn-hover: rgba(255, 255, 255, 0.1);
            --handle-color: #fff;
        }

        body { margin: 0; padding: 0; font-family: 'Inter', sans-serif; background-color: var(--bg-color); color: var(--text-color); height: 100vh; overflow: hidden; user-select: none; }
        * { box-sizing: border-box; }

        /* --- COLLAGE WORKSPACE --- */
        .main-container { display: flex; height: 100vh; width: 100%; }
        
        #collage-area {
            flex: 1;
            background-color: var(--workspace-bg);
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #collage-canvas {
            width: 800px;
            height: 600px;
            background: #ffffff;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            position: relative;
            transition: width 0.3s, height 0.3s, background 0.3s;
        }

        /* --- DRAGGABLE IMAGE ITEM --- */
        .collage-item {
            position: absolute;
            cursor: grab;
            user-select: none;
            border: 2px solid transparent;
            transition: border 0.1s;
            display: flex; justify-content: center; align-items: center;
        }
        
        .collage-item.selected {
            border: 2px solid var(--accent-color);
            z-index: 1000 !important; 
        }

        /* A belső kép konténer a vágáshoz */
        .collage-item-inner {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
            pointer-events: none;
        }

        .collage-item img {
            position: absolute; /* Fontos a vágáshoz */
            /* A vágást mostantól JS transzformációval vagy negatív margóval is kezelhetjük, 
               de a canvas drawImage-nél a vágási paraméterek döntenek. 
               A megjelenítéshez object-fit helyett mostantól pozicionálást használunk a crop esetén. */
            object-fit: fill; 
            width: 100%;
            height: 100%;
        }

        /* Resize Handle (Jobb alsó sarok) */
        .resize-handle {
            width: 12px; height: 12px;
            background: var(--accent-color);
            position: absolute;
            bottom: -6px; right: -6px;
            cursor: nwse-resize;
            border-radius: 50%;
            display: none;
            border: 1px solid white;
            z-index: 2001;
        }
        .collage-item.selected .resize-handle { display: block; }

        /* --- MINI HUD --- */
        .mini-hud {
            position: absolute;
            top: -45px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            padding: 5px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            display: none; 
            gap: 5px;
            z-index: 99999;
            white-space: nowrap;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .collage-item.selected .mini-hud { display: flex; }

        .hud-btn {
            background: transparent; border: none; color: white;
            cursor: pointer; width: 28px; height: 28px;
            border-radius: 4px; display: flex; align-items: center; justify-content: center;
            transition: background 0.2s;
        }
        .hud-btn:hover { background: rgba(255,255,255,0.2); }
        .hud-divider { width:1px; height:18px; background:rgba(255,255,255,0.2); margin:0 2px; align-self:center; }


        /* --- UI PANELEK --- */
        .floating-panel {
            position: absolute; background: var(--glass-bg); backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border); padding: 15px; border-radius: 12px;
            display: flex; flex-direction: column; gap: 10px; z-index: 100;
        }

        .toolbar-left { top: 100px; left: 20px; width: 220px; }

        .section-title { font-size: 11px; font-weight: 600; text-transform: uppercase; opacity: 0.6; margin-bottom: 5px; letter-spacing: 1px;}
        
        .tool-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .big-btn {
            background: rgba(255,255,255,0.05); border: 1px solid var(--border-color);
            color: var(--text-color); padding: 10px; border-radius: 6px; cursor: pointer;
            font-size: 12px; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 5px;
            transition: 0.2s;
        }
        .big-btn:hover { background: var(--btn-hover); border-color: var(--accent-color); }
        .big-btn .material-icons { font-size: 20px; }

        input[type="file"] { display: none; }

        /* --- HEADER --- */
        .header-wrapper { position: fixed; top: 25px; left: 0; width: 100%; display: flex; justify-content: space-between; padding: 0 40px; z-index: 1000; pointer-events: none; }
        .glass-bubble { pointer-events: auto; background: var(--glass-bg); backdrop-filter: blur(var(--glass-blur)); border: 1px solid var(--glass-border); border-radius: 100px; padding: 6px 15px; display: flex; align-items: center; gap: 10px; }
        .app-title { font-weight: 700; font-size: 14px; color: var(--text-color); display: flex; align-items: center; gap: 8px; }
        
        .icon-btn { background: transparent; border: none; color: var(--text-color); width: 36px; height: 36px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .icon-btn:hover { background: var(--btn-hover); }

        #user-btn { cursor: pointer; font-size:12px; opacity:0.8; margin-right:5px; padding: 6px 12px; border-radius: 20px; background: rgba(255,255,255,0.05); }

        /* P2P & Modal styles */
        .dropdown { position: relative; display: inline-block; }
        .dropdown-content { opacity: 0; visibility: hidden; position: absolute; right: 0; top: 45px; background: var(--glass-bg); backdrop-filter: blur(20px); min-width: 250px; border-radius: 12px; border: 1px solid var(--glass-border); padding: 10px; transition: 0.2s; transform: translateY(-10px); }
        .dropdown:hover .dropdown-content { opacity: 1; visibility: visible; transform: translateY(0); }
        
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        .modal { background: #222; padding: 20px; border-radius: 12px; width: 300px; border: 1px solid #444; color: #fff; }
        .modal h3 { margin-top: 0; font-weight: 600; }
        .modal input, .modal select { width: 100%; padding: 10px; background: #333; border: 1px solid #444; color: white; margin-bottom: 10px; border-radius: 4px; }
        .modal button { padding: 8px 16px; background: var(--accent-color); color: white; border: none; border-radius: 4px; cursor: pointer; float: right; margin-left: 10px; }
        .modal button.secondary { background: transparent; border: 1px solid #555; }

        /* --- CROP MODAL STYLES --- */
        #cropModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 20000; flex-direction: column; align-items: center; justify-content: center; }
        .crop-container { position: relative; max-width: 80vw; max-height: 80vh; border: 1px solid #444; overflow: hidden; background: #000; box-shadow: 0 0 50px rgba(0,0,0,0.5); }
        .crop-container img { display: block; max-width: 100%; max-height: 80vh; pointer-events: none; opacity: 0.5; } /* Halvány háttérkép a vágáshoz */
        
        .crop-box {
            position: absolute;
            top: 10px; left: 10px; width: 100px; height: 100px;
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5); /* Sötétítés a kereten kívül */
            cursor: move;
        }
        
        /* Crop handles */
        .ch-handle { position: absolute; width: 10px; height: 10px; background: white; border: 1px solid var(--accent-color); border-radius: 50%; }
        .ch-tl { top: -5px; left: -5px; cursor: nw-resize; }
        .ch-tr { top: -5px; right: -5px; cursor: ne-resize; }
        .ch-bl { bottom: -5px; left: -5px; cursor: sw-resize; }
        .ch-br { bottom: -5px; right: -5px; cursor: se-resize; }
        .ch-t  { top: -5px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .ch-b  { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .ch-l  { left: -5px; top: 50%; transform: translateY(-50%); cursor: w-resize; }
        .ch-r  { right: -5px; top: 50%; transform: translateY(-50%); cursor: e-resize; }

        .crop-controls { margin-top: 20px; display: flex; gap: 10px; }
        .crop-btn { padding: 10px 20px; border-radius: 5px; border: none; cursor: pointer; font-weight: bold; }
        .crop-save { background: var(--accent-color); color: white; }
        .crop-cancel { background: transparent; border: 1px solid #555; color: white; }


        /* Export Options Styling */
        .export-option { display:block; margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; cursor: pointer; border:1px solid transparent; }
        .export-option:hover { border-color: var(--accent-color); }
        .export-option.active { background: rgba(33, 150, 243, 0.2); border-color: var(--accent-color); }

        /* Toast Notification */
        .toast-container { position: fixed; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; z-index: 10001; }
        .toast { background: rgba(33, 150, 243, 0.9); backdrop-filter: blur(10px); color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); font-size: 13px; animation: slideIn 0.3s ease-out; display: flex; align-items: center; gap: 10px; }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* Loading */
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 10000; display: none; justify-content: center; align-items: center; color: var(--accent-color); }
        .user-chip { background: rgba(255,255,255,0.1); padding: 5px 10px; border-radius: 15px; font-size: 11px; margin-top:5px; display:flex; justify-content:space-between; }
    </style>
</head>
<body>

    <div id="loading-overlay">Feldolgozás...</div>
    <div class="toast-container" id="toast-area"></div>

    <div class="header-wrapper">
        <div class="glass-bubble">
            <div class="app-title">
                <span class="material-icons" style="color:var(--accent-color)">dashboard_customize</span>
                AeroCollage PRO
            </div>
            <div style="width:1px; height:20px; background:rgba(255,255,255,0.2); margin:0 5px;"></div>
            <button class="icon-btn" onclick="openExportModal()" title="Mentés beállításokkal"><span class="material-icons">download</span></button>
            <button class="icon-btn" onclick="clearCollage()" title="Összes törlése"><span class="material-icons">delete_sweep</span></button>
        </div>

        <div class="glass-bubble">
            <div id="user-btn" onclick="openLoginModal()">Belépés</div>
            
            <div class="dropdown">
                <button class="icon-btn" title="Közös Munka"><span class="material-icons">group</span></button>
                <div class="dropdown-content">
                    <h4 style="margin:0 0 10px 0; border-bottom:1px solid #444; padding-bottom:5px;">Közös Kollázs</h4>
                    <div id="p2p-controls">
                        <select id="channel-select" style="width:100%; padding:8px; background:#333; color:white; border:none; border-radius:4px; margin-bottom:5px;">
                            <option value="collage_1">Szoba 1</option>
                            <option value="collage_2">Szoba 2</option>
                        </select>
                        <div style="display:flex; gap:5px;">
                            <button onclick="startHost()" style="flex:1; padding:5px; background:var(--accent-color); border:none; color:white; border-radius:4px; cursor:pointer;">HOST</button>
                            <button onclick="joinGuest()" style="flex:1; padding:5px; background:#4CAF50; border:none; color:white; border-radius:4px; cursor:pointer;">JOIN</button>
                        </div>
                    </div>
                    <div id="p2p-status" style="display:none;">
                        <div style="color:#4CAF50; font-size:12px; margin-bottom:5px;">● Kapcsolódva</div>
                        <div id="user-list"></div>
                        <button onclick="disconnectP2P()" style="width:100%; padding:5px; background:#f44336; border:none; color:white; border-radius:4px; cursor:pointer; margin-top:5px;">Kilépés</button>
                    </div>
                </div>
            </div>

            <div class="dropdown">
                <button class="icon-btn" title="Felhő"><span class="material-icons">cloud</span></button>
                <div class="dropdown-content">
                    <a href="#" onclick="handleDriveSave()" style="display:block; padding:8px; color:#e0e0e0; text-decoration:none;"><span class="material-icons" style="font-size:14px; vertical-align:middle">save</span> Mentés Drive-ra</a>
                </div>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="floating-panel toolbar-left">
            <div class="section-title">Képek</div>
            <button class="big-btn" onclick="document.getElementById('img-input').click()">
                <span class="material-icons">add_photo_alternate</span>
                Képek Importálása
            </button>
            <input type="file" id="img-input" multiple accept="image/*" onchange="handleFiles(this.files)">

            <div style="height:10px;"></div>

            <div class="section-title">Sablonok (Auto)</div>
            <div class="tool-grid">
                <button class="big-btn" onclick="applyLayout('grid')">
                    <span class="material-icons">grid_view</span>
                    Rács
                </button>
                <button class="big-btn" onclick="applyLayout('columns')">
                    <span class="material-icons">view_column</span>
                    Oszlopok
                </button>
                <button class="big-btn" onclick="applyLayout('scatter')">
                    <span class="material-icons">grain</span>
                    Szórt
                </button>
                <button class="big-btn" onclick="applyLayout('rows')">
                    <span class="material-icons">table_rows</span>
                    Sorok
                </button>
            </div>

            <div style="height:10px;"></div>

            <div class="section-title">Vászon Beállítások</div>
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:5px;">
                <span style="font-size:12px;">Háttérszín:</span>
                <input type="color" id="canvas-bg" value="#ffffff" onchange="updateCanvasBg(this.value)" style="width:30px; height:30px; border:none; padding:0; background:none;">
            </div>
            
        </div>

        <div id="collage-area" onmousedown="deselectAll(event)">
            <div id="collage-canvas">
                </div>
        </div>
    </div>

    <div id="cropModal">
        <div class="crop-container" id="crop-container">
            <img id="crop-target-img" src="" alt="Vágandó kép">
            <div class="crop-box" id="crop-box" onmousedown="startCropDrag(event)">
                <div class="ch-handle ch-tl" onmousedown="startCropResize(event, 'tl')"></div>
                <div class="ch-handle ch-tr" onmousedown="startCropResize(event, 'tr')"></div>
                <div class="ch-handle ch-bl" onmousedown="startCropResize(event, 'bl')"></div>
                <div class="ch-handle ch-br" onmousedown="startCropResize(event, 'br')"></div>
                
                <div class="ch-handle ch-t" onmousedown="startCropResize(event, 't')"></div>
                <div class="ch-handle ch-b" onmousedown="startCropResize(event, 'b')"></div>
                <div class="ch-handle ch-l" onmousedown="startCropResize(event, 'l')"></div>
                <div class="ch-handle ch-r" onmousedown="startCropResize(event, 'r')"></div>
            </div>
        </div>
        <div class="crop-controls">
            <button class="crop-btn crop-cancel" onclick="closeCropModal()">Mégse</button>
            <button class="crop-btn crop-save" onclick="applyCrop()">Mentés</button>
        </div>
    </div>

    <div id="loginModal" class="modal-overlay">
        <div class="modal">
            <h3>Bejelentkezés</h3>
            <p style="font-size:12px; color:#aaa; margin-bottom:10px;">Add meg a neved a közös munkához.</p>
            <input type="text" id="username" placeholder="Felhasználónév">
            <div style="overflow:hidden;">
                <button onclick="login()">OK</button>
                <button class="secondary" onclick="document.getElementById('loginModal').style.display='none'">Mégse</button>
            </div>
        </div>
    </div>

    <div id="exportModal" class="modal-overlay">
        <div class="modal">
            <h3>Exportálás</h3>
            <div class="export-option active" onclick="setExportQuality(1, this)">
                <div style="font-weight:bold;">Normál (Screen)</div>
                <div style="font-size:11px; opacity:0.7;">Gyors mentés, képernyőméret (1x)</div>
            </div>
            <div class="export-option" onclick="setExportQuality(3, this)">
                <div style="font-weight:bold;">HD (Print Quality)</div>
                <div style="font-size:11px; opacity:0.7;">Nagy felbontás, nyomtatáshoz (3x skálázás)</div>
            </div>
            
            <div style="overflow:hidden; margin-top:15px;">
                <button onclick="executeSave()">Mentés</button>
                <button class="secondary" onclick="document.getElementById('exportModal').style.display='none'">Mégse</button>
            </div>
        </div>
    </div>

    <script>
        // --- CORE VARIABLES ---
        const canvas = document.getElementById('collage-canvas');
        let items = []; // { id, x, y, w, h, z, src, element, crop: {sx, sy, sw, sh} }
        let selectedItem = null;
        let zCounter = 1;
        let isDragging = false;
        let isResizing = false;
        let dragOffset = { x: 0, y: 0 };
        let startSize = { w: 0, h: 0, x: 0, y: 0 }; 
        
        let exportScale = 1; 

        // --- CROP VARIABLES ---
        let cropTargetId = null;
        let isCropDragging = false;
        let isCropResizing = false;
        let cropResizeDir = '';
        let cropStartPos = {x:0, y:0, boxL:0, boxT:0, boxW:0, boxH:0};

        // --- IMAGE HANDLING ---
        function handleFiles(files) {
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    createCollageItem(e.target.result);
                };
                reader.readAsDataURL(file);
            });
            document.getElementById('img-input').value = '';
        }

        function createCollageItem(src, remoteParams = null) {
            const id = remoteParams ? remoteParams.id : 'item_' + Date.now() + Math.random().toString(36).substr(2, 5);
            const zIndex = remoteParams ? remoteParams.z : zCounter++;

            // Crop adatok inicializálása
            let cropData = remoteParams && remoteParams.crop ? remoteParams.crop : null; // Ha nincs, null (teljes kép)

            const div = document.createElement('div');
            div.className = 'collage-item';
            div.id = id;
            div.style.zIndex = zIndex;
            
            // Inner container for crop visualization via object-position/size trick or simple image drawing
            const innerDiv = document.createElement('div');
            innerDiv.className = 'collage-item-inner';
            
            const img = document.createElement('img');
            img.src = src;
            img.onload = () => {
                // Initialize crop to full image if new
                if (!cropData) {
                    cropData = { sx: 0, sy: 0, sw: img.naturalWidth, sh: img.naturalHeight };
                }

                if (!remoteParams) {
                    let w = img.naturalWidth;
                    let h = img.naturalHeight;
                    if (w > 300) { h = (300/w)*h; w = 300; }
                    
                    div.style.width = w + 'px';
                    div.style.height = h + 'px';
                    div.style.left = (Math.random() * (canvas.clientWidth - w)) + 'px';
                    div.style.top = (Math.random() * (canvas.clientHeight - h)) + 'px';

                    syncCreate(id, src, parseFloat(div.style.left), parseFloat(div.style.top), w, h, zIndex, cropData);
                } else {
                    div.style.width = remoteParams.w + 'px';
                    div.style.height = remoteParams.h + 'px';
                    div.style.left = remoteParams.x + 'px';
                    div.style.top = remoteParams.y + 'px';
                }
                updateVisualCrop(img, cropData);
            };

            // Resize Handle
            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            
            // Mini HUD
            const hud = document.createElement('div');
            hud.className = 'mini-hud';
            hud.innerHTML = `
                <button class="hud-btn" onclick="changeLayer('${id}', 1)" title="Előre"><span class="material-icons" style="font-size:16px">arrow_upward</span></button>
                <button class="hud-btn" onclick="changeLayer('${id}', -1)" title="Hátra"><span class="material-icons" style="font-size:16px">arrow_downward</span></button>
                <div class="hud-divider"></div>
                <button class="hud-btn" onclick="openCropEditor('${id}')" title="Szerkesztés / Vágás"><span class="material-icons" style="font-size:16px">crop</span></button>
                <div class="hud-divider"></div>
                <button class="hud-btn" style="color:#ff5555" onclick="deleteItem('${id}')" title="Törlés"><span class="material-icons" style="font-size:16px">delete</span></button>
            `;

            innerDiv.appendChild(img);
            div.appendChild(innerDiv); // Wrapperbe tesszük
            div.appendChild(handle);
            div.appendChild(hud);
            canvas.appendChild(div);

            const itemObj = { id, element: div, src, crop: cropData };
            items.push(itemObj);

            div.onmousedown = (e) => startDrag(e, itemObj);
            handle.onmousedown = (e) => startResize(e, itemObj);
        }

        // --- CROP VISUALIZATION HELPER ---
        // Ez a függvény frissíti a kép megjelenését a DOM-ban, hogy tükrözze a vágást
        function updateVisualCrop(imgElement, crop) {
            if(!crop) return;
            // Mivel a DOM-ban egy <img> elem van, nem tudjuk 'valóban' levágni.
            // Trükk: object-fit helyett (vagy mellett) object-position-t és méretezést használunk?
            // VAGY: Egyszerűbb, ha a canvas drawImage-t használjuk az exportnál, itt pedig csak szimuláljuk.
            // A legpontosabb: A HTML-ben a kép src-jét lecseréljük egy ideiglenes canvasra rajzolt vágott verzióra?
            // Igen, ez a legtisztább a felhasználónak.
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = crop.sw;
            tempCanvas.height = crop.sh;
            const ctx = tempCanvas.getContext('2d');
            
            // Létrehozunk egy új Image objektumot az eredeti forrásból (mert az imgElement.src lehet már blob)
            const originalImg = new Image();
            // Keressük meg az eredeti src-t az items-ben
            const item = items.find(i => i.element.contains(imgElement));
            if(item) {
                 originalImg.src = item.src;
                 originalImg.onload = () => {
                     ctx.drawImage(originalImg, crop.sx, crop.sy, crop.sw, crop.sh, 0, 0, crop.sw, crop.sh);
                     imgElement.src = tempCanvas.toDataURL(); // Frissítjük a DOM képet a vágottra
                 };
            }
        }

        // --- CROP EDITOR FUNCTIONS ---
        function openCropEditor(id) {
            const item = items.find(i => i.id === id);
            if(!item) return;
            
            cropTargetId = id;
            const modal = document.getElementById('cropModal');
            const targetImg = document.getElementById('crop-target-img');
            const cropBox = document.getElementById('crop-box');
            
            // Betöltjük az eredeti képet (nem a vágottat)
            targetImg.src = item.src;
            
            targetImg.onload = () => {
                modal.style.display = 'flex';
                
                // Várjunk picit, hogy a kép renderelődjön és legyen mérete
                const containerRect = document.getElementById('crop-container').getBoundingClientRect();
                const imgRect = targetImg.getBoundingClientRect();

                // Kiszámoljuk az arányt a megjelenített kép és a valós méret között
                const scaleX = imgRect.width / targetImg.naturalWidth;
                const scaleY = imgRect.height / targetImg.naturalHeight;

                // Kezdeti Crop Box pozíció
                // Ha már volt crop, azt állítsuk be, ha nincs, akkor teljes kép
                let cx, cy, cw, ch;
                
                if (item.crop && item.crop.sw < targetImg.naturalWidth) {
                    cx = item.crop.sx * scaleX;
                    cy = item.crop.sy * scaleY;
                    cw = item.crop.sw * scaleX;
                    ch = item.crop.sh * scaleY;
                } else {
                    cx = 0; cy = 0; cw = imgRect.width; ch = imgRect.height;
                }

                // Pozícionálás a konténerhez képest (ami relatív)
                // A containerben a kép középen van, vagy kitölti. 
                // A crop box absolute a containerhez.
                // Korrekció: A targetImg pozíciója a containerben:
                const offsetLeft = imgRect.left - containerRect.left;
                const offsetTop = imgRect.top - containerRect.top;

                cropBox.style.left = (offsetLeft + cx) + 'px';
                cropBox.style.top = (offsetTop + cy) + 'px';
                cropBox.style.width = cw + 'px';
                cropBox.style.height = ch + 'px';
            };
        }

        function closeCropModal() {
            document.getElementById('cropModal').style.display = 'none';
            cropTargetId = null;
        }

        function applyCrop() {
            if(!cropTargetId) return;
            
            const item = items.find(i => i.id === cropTargetId);
            const targetImg = document.getElementById('crop-target-img');
            const cropBox = document.getElementById('crop-box');
            
            const imgRect = targetImg.getBoundingClientRect();
            const containerRect = document.getElementById('crop-container').getBoundingClientRect();
            
            // Kép offset a containerben
            const imgOffsetLeft = imgRect.left - containerRect.left;
            const imgOffsetTop = imgRect.top - containerRect.top;

            // CropBox pozíciója a képhez képest
            const boxLeft = parseFloat(cropBox.style.left) - imgOffsetLeft;
            const boxTop = parseFloat(cropBox.style.top) - imgOffsetTop;
            const boxWidth = parseFloat(cropBox.style.width);
            const boxHeight = parseFloat(cropBox.style.height);

            // Skála (Megjelenített / Eredeti)
            const scaleX = targetImg.naturalWidth / imgRect.width;
            const scaleY = targetImg.naturalHeight / imgRect.height;

            // Valós koordináták kiszámítása
            let finalSx = boxLeft * scaleX;
            let finalSy = boxTop * scaleY;
            let finalSw = boxWidth * scaleX;
            let finalSh = boxHeight * scaleY;

            // Határok ellenőrzése (ne lehessen negatív)
            if(finalSx < 0) finalSx = 0;
            if(finalSy < 0) finalSy = 0;
            if(finalSw > targetImg.naturalWidth - finalSx) finalSw = targetImg.naturalWidth - finalSx;
            if(finalSh > targetImg.naturalHeight - finalSy) finalSh = targetImg.naturalHeight - finalSy;

            // Adatok mentése
            item.crop = {
                sx: finalSx,
                sy: finalSy,
                sw: finalSw,
                sh: finalSh
            };

            // Vizuális frissítés
            updateVisualCrop(item.element.querySelector('img'), item.crop);
            
            // Szinkronizálás
            syncUpdate(item);
            
            closeCropModal();
        }

        // --- CROP INTERACTION (Drag & Resize) ---
        function startCropDrag(e) {
            if(e.target.classList.contains('ch-handle')) return; // Ha resize handle, ne drag
            e.stopPropagation();
            e.preventDefault();
            isCropDragging = true;
            
            const box = document.getElementById('crop-box');
            cropStartPos = {
                x: e.clientX,
                y: e.clientY,
                boxL: parseFloat(box.style.left) || 0,
                boxT: parseFloat(box.style.top) || 0
            };
        }

        function startCropResize(e, dir) {
            e.stopPropagation();
            e.preventDefault();
            isCropResizing = true;
            cropResizeDir = dir;
            
            const box = document.getElementById('crop-box');
            cropStartPos = {
                x: e.clientX,
                y: e.clientY,
                boxL: parseFloat(box.style.left) || 0,
                boxT: parseFloat(box.style.top) || 0,
                boxW: parseFloat(box.style.width) || 0,
                boxH: parseFloat(box.style.height) || 0
            };
        }

        // Globális egérkövetés a modálhoz
        document.getElementById('cropModal').addEventListener('mousemove', (e) => {
            const box = document.getElementById('crop-box');
            const img = document.getElementById('crop-target-img');
            const container = document.getElementById('crop-container');
            
            // Határok (container relatív)
            const cRect = container.getBoundingClientRect();
            const iRect = img.getBoundingClientRect();
            
            // Kép határai a containeren belül
            const minX = iRect.left - cRect.left;
            const minY = iRect.top - cRect.top;
            const maxX = minX + iRect.width;
            const maxY = minY + iRect.height;

            if (isCropDragging) {
                let dx = e.clientX - cropStartPos.x;
                let dy = e.clientY - cropStartPos.y;
                
                let newL = cropStartPos.boxL + dx;
                let newT = cropStartPos.boxT + dy;
                let newW = parseFloat(box.style.width);
                let newH = parseFloat(box.style.height);

                // Határolás (Ne menjen ki a képről)
                if (newL < minX) newL = minX;
                if (newT < minY) newT = minY;
                if (newL + newW > maxX) newL = maxX - newW;
                if (newT + newH > maxY) newT = maxY - newH;

                box.style.left = newL + 'px';
                box.style.top = newT + 'px';
            }

            if (isCropResizing) {
                let dx = e.clientX - cropStartPos.x;
                let dy = e.clientY - cropStartPos.y;
                
                let newL = cropStartPos.boxL;
                let newT = cropStartPos.boxT;
                let newW = cropStartPos.boxW;
                let newH = cropStartPos.boxH;

                if (cropResizeDir.includes('r')) newW += dx;
                if (cropResizeDir.includes('l')) { newL += dx; newW -= dx; }
                if (cropResizeDir.includes('b')) newH += dy;
                if (cropResizeDir.includes('t')) { newT += dy; newH -= dy; }

                // Min size
                if (newW < 20) newW = 20;
                if (newH < 20) newH = 20;

                // Határolás (Resize közben se menjen ki)
                if (newL < minX) { newW += (newL - minX); newL = minX; }
                if (newT < minY) { newH += (newT - minY); newT = minY; }
                if (newL + newW > maxX) newW = maxX - newL;
                if (newT + newH > maxY) newH = maxY - newT;

                box.style.left = newL + 'px';
                box.style.top = newT + 'px';
                box.style.width = newW + 'px';
                box.style.height = newH + 'px';
            }
        });

        document.getElementById('cropModal').addEventListener('mouseup', () => {
            isCropDragging = false;
            isCropResizing = false;
        });


        // --- INTERACTION ENGINE (Canvas) ---

        function startDrag(e, item) {
            if (e.target.closest('.hud-btn') || e.target.classList.contains('resize-handle')) return;
            e.stopPropagation();
            e.preventDefault();
            
            selectItem(item);
            isDragging = true;
            
            const rect = item.element.getBoundingClientRect();
            // Calculate offset within the element
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
        }

        function startResize(e, item) {
            e.stopPropagation();
            e.preventDefault();
            isResizing = true;
            selectItem(item);
            
            startSize = {
                w: item.element.offsetWidth,
                h: item.element.offsetHeight,
                x: e.clientX,
                y: e.clientY
            };
        }

        function selectItem(item) {
            if (selectedItem) selectedItem.element.classList.remove('selected');
            selectedItem = item;
            item.element.classList.add('selected');
        }

        function deselectAll(e) {
            if (e.target.id === 'collage-area' || e.target.id === 'collage-canvas') {
                if (selectedItem) selectedItem.element.classList.remove('selected');
                selectedItem = null;
            }
        }

        // Global Mouse Move / Up
        window.addEventListener('mousemove', (e) => {
            if (!selectedItem) return;
            // Ne csináljon semmit, ha a Crop Modal nyitva van
            if(document.getElementById('cropModal').style.display === 'flex') return;

            if (isDragging) {
                const canvasRect = canvas.getBoundingClientRect();
                let newX = e.clientX - canvasRect.left - dragOffset.x;
                let newY = e.clientY - canvasRect.top - dragOffset.y;

                selectedItem.element.style.left = newX + 'px';
                selectedItem.element.style.top = newY + 'px';
            } 
            else if (isResizing) {
                const dx = e.clientX - startSize.x;
                const dy = e.clientY - startSize.y;
                
                let newW = startSize.w + dx;
                let newH = startSize.h + dy;

                if (newW < 20) newW = 20;
                if (newH < 20) newH = 20;

                selectedItem.element.style.width = newW + 'px';
                selectedItem.element.style.height = newH + 'px';
            }
        });

        window.addEventListener('mouseup', () => {
            if ((isDragging || isResizing) && selectedItem) {
                syncUpdate(selectedItem);
            }
            isDragging = false;
            isResizing = false;
        });

        // --- ITEM MANIPULATION ---

        function changeLayer(id, direction) {
            const item = items.find(i => i.id === id);
            if (!item) return;
            
            let currentZ = parseInt(item.element.style.zIndex);
            let newZ = currentZ + direction;
            if (newZ < 0) newZ = 0;
            
            item.element.style.zIndex = newZ;
            if (newZ >= zCounter) zCounter = newZ + 1;
            syncUpdate(item);
        }

        function deleteItem(id) {
            const index = items.findIndex(i => i.id === id);
            if (index > -1) {
                items[index].element.remove();
                items.splice(index, 1);
                selectedItem = null;
                syncDelete(id);
            }
        }

        function updateCanvasBg(color) {
            canvas.style.backgroundColor = color;
            if (p2pHost) broadcast({ type: 'bg_change', color });
        }

        // --- LAYOUTS (TEMPLATES) ---
        function applyLayout(type) {
            if (items.length === 0) return;
            
            const count = items.length;
            const canvasW = canvas.offsetWidth;
            const canvasH = canvas.offsetHeight;

            if (type === 'grid') {
                const cols = Math.ceil(Math.sqrt(count));
                const rows = Math.ceil(count / cols);
                const cellW = canvasW / cols;
                const cellH = canvasH / rows;

                items.forEach((item, i) => {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    item.element.style.width = (cellW - 10) + 'px';
                    item.element.style.height = (cellH - 10) + 'px';
                    item.element.style.left = (col * cellW + 5) + 'px';
                    item.element.style.top = (row * cellH + 5) + 'px';
                    syncUpdate(item);
                });
            } else if (type === 'columns') {
                const w = canvasW / count;
                items.forEach((item, i) => {
                    item.element.style.width = (w - 10) + 'px';
                    item.element.style.height = (canvasH - 20) + 'px';
                    item.element.style.left = (i * w + 5) + 'px';
                    item.element.style.top = '10px';
                    syncUpdate(item);
                });
            } else if (type === 'rows') {
                const h = canvasH / count;
                items.forEach((item, i) => {
                    item.element.style.width = (canvasW - 20) + 'px';
                    item.element.style.height = (h - 10) + 'px';
                    item.element.style.left = '10px';
                    item.element.style.top = (i * h + 5) + 'px';
                    syncUpdate(item);
                });
            } else if (type === 'scatter') {
                items.forEach(item => {
                    item.element.style.width = '200px';
                    item.element.style.height = '200px'; // Scatter is mostly random
                    item.element.style.left = (Math.random() * (canvasW - 200)) + 'px';
                    item.element.style.top = (Math.random() * (canvasH - 200)) + 'px';
                    syncUpdate(item);
                });
            }
        }

        // --- EXPORT LOGIC ---
        function openExportModal() {
            document.getElementById('exportModal').style.display = 'flex';
        }

        function setExportQuality(scale, el) {
            exportScale = scale;
            document.querySelectorAll('.export-option').forEach(e => e.classList.remove('active'));
            el.classList.add('active');
        }

        function executeSave() {
            document.getElementById('exportModal').style.display = 'none';
            document.getElementById('loading-overlay').style.display = 'flex';
            
            setTimeout(() => {
                saveCollageHighQuality(exportScale);
                document.getElementById('loading-overlay').style.display = 'none';
            }, 100);
        }

        function saveCollageHighQuality(scale = 1) {
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.offsetWidth * scale;
            exportCanvas.height = canvas.offsetHeight * scale;
            const ctx = exportCanvas.getContext('2d');

            ctx.fillStyle = canvas.style.backgroundColor || '#ffffff';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

            const sortedItems = [...items].sort((a, b) => {
                return parseInt(a.element.style.zIndex) - parseInt(b.element.style.zIndex);
            });

            // Promise alapú betöltés a biztos rendereléshez (bár itt már be vannak töltve, de a biztonság kedvéért új Image objektumok)
            // Egyszerűsített szinkron megoldás (mivel a DOM-ban ott vannak)
            sortedItems.forEach(item => {
                // Új image objektum létrehozása az eredeti source-ból
                // Fontos: Nem a DOM img-t használjuk, mert az lehet, hogy már base64 vágott. 
                // Az eredeti src-t használjuk és a crop adatokat.
                const tempImg = new Image();
                tempImg.src = item.src;
                
                // Mivel a tempImg.src lehet aszinkron, itt egy trükk: a drawImage működik, ha már be volt töltve böngésző cache-be.
                // De a biztonság kedvéért (ha nagy képek):
                // A legegyszerűbb, ha a DOM img-t használjuk, de az már a "vizuális vágott" verzió lehet.
                // HA a visualCrop update lecserélte az src-t, akkor azt rajzoljuk ki direktben, crop paraméterek NÉLKÜL (mert már vágott).
                // HA az eredeti src van (nincs crop), akkor mehet simán.
                
                const domImg = item.element.querySelector('img');
                
                const dx = parseFloat(item.element.style.left) * scale;
                const dy = parseFloat(item.element.style.top) * scale;
                const dw = parseFloat(item.element.style.width) * scale;
                const dh = parseFloat(item.element.style.height) * scale;

                // Ha van vágás, a DOM kép már a vágott verzió (base64). Így a teljes képet rajzoljuk ki a cél területre.
                // Ez azért jó, mert a vizuális frissítésnél már megcsináltuk a vágást.
                ctx.drawImage(domImg, 0, 0, domImg.naturalWidth, domImg.naturalHeight, dx, dy, dw, dh);
            });

            const link = document.createElement('a');
            const suffix = scale > 1 ? '_HD' : '';
            link.download = `AeroCollage${suffix}_${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png', 1.0); 
            link.click();
        }

        function clearCollage() {
            if(confirm("Biztos törölsz mindent?")) {
                canvas.innerHTML = '';
                items = [];
                if(p2pHost) broadcast({type: 'clear'});
            }
        }

        // --- UTILS ---
        function showToast(msg) {
            const container = document.getElementById('toast-area');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerHTML = `<span class="material-icons">info</span> ${msg}`;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // --- P2P SYNC ---
        let peer, conn, p2pHost = false;
        let currentUser = null;

        function login() {
            currentUser = document.getElementById('username').value;
            if(!currentUser) return;
            document.getElementById('user-btn').innerText = currentUser;
            document.getElementById('loginModal').style.display = 'none';
        }
        function openLoginModal() { document.getElementById('loginModal').style.display='flex'; }

        function startHost() {
            if(!currentUser) { openLoginModal(); return; }
            p2pHost = true;
            initPeer(document.getElementById('channel-select').value);
        }
        function joinGuest() {
            if(!currentUser) { openLoginModal(); return; }
            p2pHost = false;
            initPeer(null);
        }

        function initPeer(id) {
            peer = new Peer(id);
            peer.on('open', () => {
                document.getElementById('p2p-controls').style.display='none';
                document.getElementById('p2p-status').style.display='block';
                showToast("P2P kapcsolat elindítva");
                if(!p2pHost) {
                    conn = peer.connect(document.getElementById('channel-select').value);
                    setupConn(conn);
                    conn.on('open', () => {
                        conn.send({type: 'hello', username: currentUser});
                    });
                }
            });
            peer.on('connection', (c) => {
                setupConn(c);
                setTimeout(() => {
                    items.forEach(i => {
                        c.send({
                            type: 'create',
                            id: i.id, src: i.src,
                            x: parseFloat(i.element.style.left),
                            y: parseFloat(i.element.style.top),
                            w: parseFloat(i.element.style.width),
                            h: parseFloat(i.element.style.height),
                            z: parseInt(i.element.style.zIndex),
                            crop: i.crop // Sync crop data
                        });
                    });
                }, 1000);
            });
            peer.on('error', (err) => {
                alert("Hiba: " + err.type);
            });
        }

        function setupConn(c) {
            c.on('data', (data) => {
                if(data.type === 'hello') {
                    showToast(`${data.username} csatlakozott a kollázshoz!`);
                }

                if(data.type === 'create') {
                    if(!items.find(i => i.id === data.id)) {
                        createCollageItem(data.src, data);
                    }
                } else if(data.type === 'update') {
                    const item = items.find(i => i.id === data.id);
                    if(item) {
                        item.element.style.left = data.x + 'px';
                        item.element.style.top = data.y + 'px';
                        item.element.style.width = data.w + 'px';
                        item.element.style.height = data.h + 'px';
                        item.element.style.zIndex = data.z;
                        
                        // Crop sync update
                        if(data.crop) {
                            item.crop = data.crop;
                            updateVisualCrop(item.element.querySelector('img'), item.crop);
                        }
                    }
                } else if(data.type === 'delete') {
                    const index = items.findIndex(i => i.id === data.id);
                    if(index > -1) {
                        items[index].element.remove();
                        items.splice(index, 1);
                    }
                } else if(data.type === 'bg_change') {
                    canvas.style.backgroundColor = data.color;
                    document.getElementById('canvas-bg').value = data.color;
                } else if(data.type === 'clear') {
                    canvas.innerHTML = '';
                    items = [];
                }
            });
        }

        function syncCreate(id, src, x, y, w, h, z, crop) {
            if(peer) broadcast({ type: 'create', id, src, x, y, w, h, z, crop });
        }
        function syncUpdate(item) {
            if(peer) broadcast({
                type: 'update',
                id: item.id,
                x: parseFloat(item.element.style.left),
                y: parseFloat(item.element.style.top),
                w: parseFloat(item.element.style.width),
                h: parseFloat(item.element.style.height),
                z: parseInt(item.element.style.zIndex),
                crop: item.crop // Küldjük a crop adatokat is
            });
        }
        function syncDelete(id) {
            if(peer) broadcast({ type: 'delete', id });
        }
        function broadcast(msg) {
            if(p2pHost) {
                for(let conId in peer.connections) {
                    peer.connections[conId].forEach(c => c.send(msg));
                }
            } else if(conn) {
                conn.send(msg);
            }
        }
        function disconnectP2P() {
            if(peer) peer.destroy();
            location.reload();
        }

        // --- DRIVE SAVING ---
        const CLIENT_ID = '138100233309-v575n23j2b6pdek9t9clvkg3immlkrdi.apps.googleusercontent.com'; 
        const API_KEY = 'AIzaSyAfC2viqoOsVVjcShnqY2rrRsxdV7WHMEg'; 
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';
        let gapiInited=false, gisInited=false, tokenClient;
        function gapiLoaded(){gapi.load('client',async()=>{await gapi.client.init({apiKey:API_KEY,discoveryDocs:[DISCOVERY_DOC]});gapiInited=true;});}
        function gisLoaded(){tokenClient=google.accounts.oauth2.initTokenClient({client_id:CLIENT_ID,scope:SCOPES,callback:(r)=>{}});gisInited=true;}

        async function handleDriveSave() {
            if(!currentUser) { alert("Jelentkezz be!"); return; }
            if(!gapiInited || !gisInited) return;
            
            tokenClient.callback = async (resp) => {
                if(resp.error) return;
                
                const scale = 2; 
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = canvas.offsetWidth * scale; exportCanvas.height = canvas.offsetHeight * scale;
                const ctx = exportCanvas.getContext('2d');
                ctx.fillStyle = canvas.style.backgroundColor || '#ffffff'; ctx.fillRect(0,0,exportCanvas.width,exportCanvas.height);
                
                const sortedItems = [...items].sort((a,b)=>parseInt(a.element.style.zIndex)-parseInt(b.element.style.zIndex));
                sortedItems.forEach(item=>{
                    const img = item.element.querySelector('img');
                    const dx = parseFloat(item.element.style.left)*scale, dy = parseFloat(item.element.style.top)*scale;
                    const dw = parseFloat(item.element.style.width)*scale, dh = parseFloat(item.element.style.height)*scale;
                    
                    // Itt is a már vágott DOM képet rajzoljuk ki
                    ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, dx, dy, dw, dh);
                });
                
                exportCanvas.toBlob(async blob => {
                    const meta = {'name':`AeroCollage_${Date.now()}.png`, 'mimeType':'image/png'};
                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(meta)],{type:'application/json'}));
                    form.append('file', blob);
                    await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                        method:'POST', headers: new Headers({'Authorization': 'Bearer '+gapi.client.getToken().access_token}), body: form
                    });
                    showToast("Sikeres mentés Google Drive-ra!");
                });
            };
            tokenClient.requestAccessToken({prompt: ''});
        }
    </script>
</body>
</html>
