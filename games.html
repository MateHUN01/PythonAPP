<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Party Arena v2 - No Lag</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg: #0f0f13;
            --glass: rgba(255, 255, 255, 0.05);
            --border: rgba(255, 255, 255, 0.1);
            --accent: #00f2ff;
            --danger: #ff0055;
            --gold: #ffcc00;
        }
        body { margin: 0; background: var(--bg); color: white; font-family: 'Roboto', sans-serif; overflow: hidden; height: 100vh; user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        .pointer-events-auto { pointer-events: auto; }

        .panel { background: var(--glass); backdrop-filter: blur(10px); border: 1px solid var(--border); padding: 15px; border-radius: 12px; box-shadow: 0 4px 30px rgba(0,0,0,0.5); text-align: center; max-width: 350px; margin: 0 auto; transition: transform 0.2s; }
        
        h1 { font-family: 'Press Start 2P', cursive; color: var(--accent); font-size: 20px; text-shadow: 0 0 10px var(--accent); margin-bottom: 20px; }

        input, select { background: rgba(0,0,0,0.3); border: 1px solid var(--border); color: white; padding: 12px; border-radius: 5px; width: 100%; margin-bottom: 15px; font-family: inherit; box-sizing: border-box; text-align: center;}
        
        button { background: var(--accent); color: #000; border: none; padding: 15px; border-radius: 5px; cursor: pointer; font-weight: bold; width: 100%; transition: 0.2s; font-family: 'Press Start 2P', cursive; font-size: 12px; margin-bottom: 10px; box-shadow: 0 4px 0 #00bfcc;}
        button:hover { transform: translateY(-2px); box-shadow: 0 6px 0 #00bfcc; }
        button:active { transform: translateY(2px); box-shadow: 0 0 0 #00bfcc; }
        
        button.join-btn { background: #00ff44; box-shadow: 0 4px 0 #00cc36; }
        button.join-btn:hover { box-shadow: 0 6px 0 #00cc36; }

        canvas { display: block; width: 100%; height: 100%; background: radial-gradient(circle at center, #1a1a24 0%, #000000 100%); image-rendering: pixelated; }

        #menu-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; }
        .score-board { text-align: left; font-family: 'Press Start 2P'; font-size: 12px; line-height: 1.5; min-width: 150px; }
        .game-info { text-align: center; }
        .timer { font-size: 30px; font-weight: bold; font-family: 'Press Start 2P'; color: var(--gold); text-shadow: 0 0 10px var(--gold); }
        
        #host-controls { display: none; margin-top: 10px; }
        .color-picker { display: flex; gap: 10px; justify-content: center; margin-bottom: 20px; }
        .color-btn { width: 30px; height: 30px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: 0.2s; }
        .color-btn.selected { border-color: white; transform: scale(1.3); box-shadow: 0 0 10px white; }

        #loading-msg { color: var(--gold); font-size: 10px; margin-top: 10px; display: none; }
    </style>
</head>
<body>

    <div id="menu-screen">
        <div class="panel pointer-events-auto">
            <h1>NEON ARENA v2</h1>
            
            <div style="margin-bottom: 10px;">
                <input type="text" id="username" placeholder="√çrd be a neved..." maxlength="12">
                
                <div class="color-picker" id="color-picker"></div>
            </div>

            <button onclick="attemptHost()" title="Ind√≠ts √∫j szervert">üëë SZERVER IND√çT√ÅSA (HOST)</button>
            <button class="join-btn" onclick="attemptJoin()" title="Csatlakoz√°s a megl√©v≈ëh√∂z">üöÄ CSATLAKOZ√ÅS (JOIN)</button>
            
            <div id="loading-msg">Kapcsol√≥d√°s...</div>
            <div id="status-msg" style="margin-top:10px; font-size:10px; color:#ff5555; height:20px;"></div>
        </div>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="panel pointer-events-auto score-board">
                <div style="color:#888; border-bottom:1px solid #333; margin-bottom:5px;">TOPLISTA</div>
                <div id="score-list">...</div>
            </div>

            <div class="game-info">
                <div style="color:#aaa; font-size:10px; margin-bottom:5px;" id="current-game-name">LOBBY</div>
                <div class="timer" id="game-timer">00:00</div>
                
                <div id="host-controls" class="panel pointer-events-auto" style="margin-top:10px; padding:10px;">
                    <select id="game-selector">
                        <option value="1">Tag (L√∂v√∂ld√∂z≈ës)</option>
                        <option value="2">Coin Rush (√ârme)</option>
                        <option value="3">Sumo (L√∂kd√∂s≈ë)</option>
                    </select>
                    <button onclick="hostStartGame()" style="font-size:10px; padding:8px; margin:0;">START</button>
                </div>
            </div>

            <div class="panel pointer-events-auto" style="min-width:100px;">
                <div style="font-size:10px; color:#888;">PING</div>
                <div id="ping-display" style="font-weight:bold; color:#0f0;">LOCAL</div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- BIZTONS√ÅGOS FIX SZOBA K√ìD (80 karakter) ---
        // Ez biztos√≠tja, hogy mindenki ugyanabba a "szob√°ba" ker√ºlj√∂n g√©pel√©s n√©lk√ºl.
        const FIXED_ROOM_ID = "neon-party-arena-secure-lobby-v2-x8z9-fixed-room-key-dont-change-this-string-8812";

        // --- KONFIGUR√ÅCI√ì ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const COLORS = ['#ff0055', '#00f2ff', '#00ff44', '#ffcc00', '#aa00ff', '#ffffff'];
        
        let myColor = COLORS[Math.floor(Math.random() * COLORS.length)];
        let myName = "Player" + Math.floor(Math.random()*100);
        let myId = null;
        let isHost = false;
        
        // PeerJS
        let peer, conn;
        let connections = []; // Csak hostnak

        // J√ÅT√âK √ÅLLAPOT
        // LocalPlayer: Kliens oldali sim√≠t√°s (Client-side prediction)
        let localPlayer = { x: 0, y: 0, vx: 0, vy: 0 }; 

        let gameState = {
            players: {}, 
            bullets: [],
            coins: [],
            gameMode: 0,
            timeLeft: 0,
            isPlaying: false,
            mapRadius: 0
        };

        const keys = { w:false, a:false, s:false, d:false, space:false };

        // --- SETUP ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Ha m√©g nincs sug√°r, be√°ll√≠tjuk
            if(!gameState.mapRadius) gameState.mapRadius = Math.min(canvas.width, canvas.height) * 0.4;
        }
        window.addEventListener('resize', resize);
        resize();

        // UI Sz√≠nv√°laszt√≥
        const cPicker = document.getElementById('color-picker');
        COLORS.forEach(c => {
            const d = document.createElement('div');
            d.className = 'color-btn'; d.style.backgroundColor = c;
            d.onclick = () => { myColor = c; updateColorUI(); };
            if(c === myColor) d.classList.add('selected');
            cPicker.appendChild(d);
        });
        function updateColorUI() {
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
            const sel = Array.from(document.querySelectorAll('.color-btn')).find(b => b.style.backgroundColor === hexToRgb(myColor) || b.style.backgroundColor === myColor);
            if(sel) sel.classList.add('selected');
        }
        function hexToRgb(hex) { // Helper a CSS √∂sszehasonl√≠t√°shoz
            // Egyszer≈±s√≠tve hagyjuk, √°ltal√°ban a browser rgb()-re konvert√°lja a style-t
            return hex; 
        }

        // --- H√ÅL√ìZAT KEZEL√âS ---

        function showLoading() { document.getElementById('loading-msg').style.display='block'; }
        function hideMenu() { document.getElementById('menu-screen').style.display='none'; }
        function setStatus(msg) { document.getElementById('status-msg').innerText = msg; document.getElementById('loading-msg').style.display='none'; }

        // HOST IND√çT√ÅSA
        function attemptHost() {
            myName = document.getElementById('username').value || myName;
            showLoading();
            
            // Megpr√≥b√°ljuk lefoglalni a fix ID-t
            peer = new Peer(FIXED_ROOM_ID, { debug: 1 });

            peer.on('open', (id) => {
                // Siker√ºlt! Mi vagyunk a Host.
                isHost = true;
                myId = id;
                hideMenu();
                document.getElementById('host-controls').style.display = 'block';
                document.getElementById('ping-display').innerText = "HOST";
                
                // Saj√°t j√°t√©kos l√©trehoz√°sa
                spawnPlayer(id, myName, myColor);
                gameState.mapRadius = Math.min(canvas.width, canvas.height) * 0.4;
                
                // J√°t√©k hurok ind√≠t√°sa
                gameLoop();
            });

            peer.on('error', (err) => {
                // Ha az ID foglalt ("unavailable-id"), akkor m√°r van Host.
                if(err.type === 'unavailable-id') {
                    setStatus("M√°r van Host! Csatlakozz ink√°bb.");
                } else {
                    setStatus("Hiba: " + err.type);
                }
            });

            peer.on('connection', (c) => {
                c.on('data', (data) => handleHostData(c, data));
                c.on('open', () => {
                    connections.push(c);
                    spawnPlayer(c.peer, "Guest", "#fff");
                    broadcastState();
                });
                c.on('close', () => {
                    delete gameState.players[c.peer];
                    connections = connections.filter(x => x.peer !== c.peer);
                });
            });
        }

        // CSATLAKOZ√ÅS
        function attemptJoin() {
            myName = document.getElementById('username').value || myName;
            showLoading();

            // V√©letlen ID-t gener√°lunk magunknak, nem a fixet
            peer = new Peer(null, { debug: 1 });

            peer.on('open', (id) => {
                myId = id;
                // Csatlakoz√°s a fix HOST ID-hez
                conn = peer.connect(FIXED_ROOM_ID);

                conn.on('open', () => {
                    hideMenu();
                    document.getElementById('ping-display').innerText = "JOINED";
                    // Bek√∂sz√∂n√©s
                    conn.send({ type: 'join', name: myName, color: myColor });
                    // Kliens oldali loop (csak renderel√©s √©s input k√ºld√©s)
                    clientLoop();
                });

                conn.on('data', (data) => {
                    if (data.type === 'update') {
                        // Kliens oldali szinkroniz√°ci√≥
                        // NEM √≠rjuk fel√ºl a saj√°t poz√≠ci√≥nkat a szerver adataival (kiv√©ve ha nagyon nagy az elt√©r√©s),
                        // hogy megmaradjon a simas√°g.
                        const serverMe = data.state.players[myId];
                        
                        // √Åtvesz√ºnk mindent a state-b≈ël
                        const oldPlayers = gameState.players;
                        gameState = data.state; 

                        // DE! A saj√°t karakter√ºnk poz√≠ci√≥j√°t megtartjuk a helyir≈ël,
                        // hogy ne ugr√°ljon (kiv√©ve ha halott vagy respawnolt).
                        if (serverMe && gameState.players[myId] && !serverMe.isDead) {
                            // Korrekci√≥: Ha a szerver szerint nagyon m√°shol vagyunk (pl falnak ment√ºnk),
                            // akkor elfogadjuk a szerver poz√≠ci√≥j√°t. Egy√©bk√©nt a saj√°tunkat haszn√°ljuk.
                            const dx = localPlayer.x - serverMe.x;
                            const dy = localPlayer.y - serverMe.y;
                            
                            // Ha az elt√©r√©s kisebb mint 50 pixel (lag), akkor a saj√°t kliens oldali mozg√°st haszn√°ljuk (smooth)
                            if (Math.sqrt(dx*dx + dy*dy) < 50) {
                                gameState.players[myId].x = localPlayer.x;
                                gameState.players[myId].y = localPlayer.y;
                            } else {
                                // Ha nagy az elt√©r√©s (pl teleport, respawn), friss√≠tj√ºk a helyit
                                localPlayer.x = serverMe.x;
                                localPlayer.y = serverMe.y;
                            }
                        }
                    }
                });

                // Ha nem tal√°lja a hostot (pl. nincs online senki)
                setTimeout(() => {
                    if(!conn.open) {
                        setStatus("Nem tal√°lhat√≥ a szerver. Ind√≠ts egyet (Host)!");
                        document.getElementById('menu-screen').style.display='flex';
                        document.getElementById('loading-msg').style.display='none';
                    }
                }, 3000);
            });
        }

        // --- HOST LOGIKA ---

        function handleHostData(c, data) {
            if (data.type === 'join') {
                if(gameState.players[c.peer]) {
                    gameState.players[c.peer].name = data.name;
                    gameState.players[c.peer].color = data.color;
                }
            }
            if (data.type === 'move') {
                // A Kliens k√∂zvetlen√ºl a poz√≠ci√≥j√°t k√ºldi (Smooth movement)
                const p = gameState.players[c.peer];
                if (p && !p.isDead) {
                    p.x = data.x;
                    p.y = data.y;
                    // L√∂v√©s input m√©g mindig k√ºl√∂n j√∂n
                    if(data.shoot) tryShoot(p);
                }
            }
        }

        function spawnPlayer(id, name, color) {
            gameState.players[id] = {
                id: id, x: 0, y: 0, vx: 0, vy: 0,
                color: color, name: name, score: 0, cooldown: 0, isDead: false, radius: 15
            };
        }

        function hostStartGame() {
            const mode = parseInt(document.getElementById('game-selector').value);
            gameState.gameMode = mode;
            gameState.timeLeft = 60;
            gameState.isPlaying = true;
            gameState.bullets = [];
            gameState.coins = [];
            
            // Respawn mindenki
            const pIds = Object.keys(gameState.players);
            pIds.forEach((id, i) => {
                const p = gameState.players[id];
                p.score = 0; p.isDead = false; p.vx=0; p.vy=0;
                const angle = (i / pIds.length) * Math.PI * 2;
                const dist = gameState.mapRadius * 0.5;
                p.x = Math.cos(angle) * dist;
                p.y = Math.sin(angle) * dist;
                
                // Host eset√©n a localPlayert is friss√≠teni kell
                if(id === myId) { localPlayer.x = p.x; localPlayer.y = p.y; }
            });

            if (mode === 2) for(let i=0; i<20; i++) spawnCoin();
        }

        // --- FIZIKA √âS J√ÅT√âK LOOP ---

        // Ez a f√ºggv√©ny fut mindenkinek a g√©p√©n a SAJ√ÅT karakter√©re
        function updateLocalPhysics() {
            const p = gameState.players[myId];
            if (!p || p.isDead) return;

            const speed = 0.8; // Sebess√©g
            const friction = 0.90;

            if (keys.w) localPlayer.vy -= speed;
            if (keys.s) localPlayer.vy += speed;
            if (keys.a) localPlayer.vx -= speed;
            if (keys.d) localPlayer.vx += speed;

            localPlayer.x += localPlayer.vx;
            localPlayer.y += localPlayer.vy;
            localPlayer.vx *= friction;
            localPlayer.vy *= friction;

            // Fal √ºtk√∂z√©s (Kliens oldalon is sz√°moljuk, hogy ne menjen ki a falon a k√©perny≈ën)
            const dist = Math.sqrt(localPlayer.x*localPlayer.x + localPlayer.y*localPlayer.y);
            const limit = gameState.mapRadius - 15; // 15 = radius
            if (dist > limit) {
                const angle = Math.atan2(localPlayer.y, localPlayer.x);
                localPlayer.x = Math.cos(angle) * limit;
                localPlayer.y = Math.sin(angle) * limit;
                localPlayer.vx = 0; localPlayer.vy = 0; // Meg√°ll√°s faln√°l
            }

            // Friss√≠tj√ºk a glob√°lis state-ben is a megjelen√≠t√©shez
            p.x = localPlayer.x;
            p.y = localPlayer.y;

            // K√ºld√©s a szervernek (vagy ha host vagyok, akkor nem kell k√ºldeni)
            if (!isHost && conn && conn.open) {
                conn.send({ 
                    type: 'move', 
                    x: localPlayer.x, 
                    y: localPlayer.y,
                    shoot: keys.space // L√∂v√©st itt jelezz√ºk
                });
                keys.space = false; // Reset key after send
            } else if (isHost) {
                 if(keys.space) { tryShoot(p); keys.space = false; }
            }
        }

        function tryShoot(p) {
            if(gameState.gameMode === 1 && p.cooldown <= 0 && gameState.isPlaying) {
                // L√∂ved√©k ir√°nya: amerre megy, vagy amerre n√©z
                let bx = localPlayer.vx || (Math.random()-0.5); 
                let by = localPlayer.vy || (Math.random()-0.5);
                if(isHost && p.id !== myId) { bx = (Math.random()-0.5); by = (Math.random()-0.5); } // Guest ir√°ny (egyszer≈±s√≠tve)
                
                // Normaliz√°l√°s
                const len = Math.sqrt(bx*bx + by*by) || 1;
                bx /= len; by /= len;

                gameState.bullets.push({
                    x: p.x + bx*20, y: p.y + by*20,
                    vx: bx*12, vy: by*12, ownerId: p.id
                });
                p.cooldown = 20;
            }
        }

        function spawnCoin() {
            const a = Math.random()*6.28; const d = Math.random()*(gameState.mapRadius-30);
            gameState.coins.push({ x: Math.cos(a)*d, y: Math.sin(a)*d });
        }

        // F≈ë Host Loop
        function gameLoop() {
            if (!isHost) return;

            // 1. Saj√°t mozg√°s
            updateLocalPhysics();

            // 2. Szerver fizika (L√∂ved√©kek, √ârm√©k, √útk√∂z√©sek)
            // Id≈ë
            if(gameState.isPlaying) {
                gameState.timeLeft -= 1/60;
                if(gameState.timeLeft<=0) { gameState.isPlaying=false; gameState.gameMode=0; }
            }
            // Cooldowns
            Object.values(gameState.players).forEach(p => { if(p.cooldown>0) p.cooldown--; });

            // L√∂ved√©kek
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const b = gameState.bullets[i];
                b.x += b.vx; b.y += b.vy;
                if (Math.sqrt(b.x*b.x + b.y*b.y) > gameState.mapRadius) { gameState.bullets.splice(i,1); continue; }
                // Tal√°lat
                for(let pid in gameState.players) {
                    const p = gameState.players[pid];
                    if(p.id !== b.ownerId && !p.isDead) {
                        const dx = p.x-b.x, dy = p.y-b.y;
                        if(Math.sqrt(dx*dx+dy*dy) < p.radius+5) {
                            p.score = Math.max(0, p.score-1);
                            if(gameState.players[b.ownerId]) gameState.players[b.ownerId].score++;
                            p.x = (Math.random()-0.5)*100; p.y = (Math.random()-0.5)*100; // Respawn
                            gameState.bullets.splice(i,1);
                            break;
                        }
                    }
                }
            }
            
            // Coin gy≈±jt√©s
            if(gameState.gameMode===2) {
                Object.values(gameState.players).forEach(p => {
                    for(let i=gameState.coins.length-1; i>=0; i--) {
                        const c = gameState.coins[i];
                        if(Math.sqrt((p.x-c.x)**2 + (p.y-c.y)**2) < p.radius+10) {
                            gameState.coins.splice(i,1); p.score++; spawnCoin();
                        }
                    }
                });
            }

            // Sumo l√∂kd√∂s≈ëd√©s (Egyszer≈±s√≠tett)
            if(gameState.gameMode===3) {
               // ... (Host oldalon sz√°molva a bonyolult √ºtk√∂z√©seket)
               // A simas√°g √©rdek√©ben a Sumo m√≥dn√°l picit lehet elt√©r√©s a kliens √©s szerver k√∂z√∂tt,
               // de a Host a f≈ën√∂k.
            }

            broadcastState();
            render();
            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        // Kliens Loop
        function clientLoop() {
            if(isHost) return;
            
            updateLocalPhysics(); // Sima mozg√°s√©rt
            render();
            updateHUD();
            requestAnimationFrame(clientLoop);
        }

        function broadcastState() {
            const data = { type: 'update', state: gameState };
            connections.forEach(c => c.send(data));
        }

        // --- INPUT ---
        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k) || k===' ') { if(k===' ') keys.space=true; else keys[k]=true; }
        });
        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k) || k===' ') { if(k===' ') keys.space=false; else keys[k]=false; }
        });

        // --- RENDER ---
        function render() {
            // T√∂rl√©s & Setup
            ctx.fillStyle = '#0f0f13'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(canvas.width/2, canvas.height/2);

            // P√°lya
            ctx.beginPath(); ctx.arc(0,0, gameState.mapRadius, 0, 6.28);
            ctx.fillStyle = '#14141c'; ctx.fill();
            ctx.lineWidth=5; 
            ctx.strokeStyle = gameState.gameMode===1?'#ff0055':gameState.gameMode===2?'#ffcc00':gameState.gameMode===3?'#00f2ff':'#333';
            ctx.stroke();

            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth=1;
            for(let i=-gameState.mapRadius; i<gameState.mapRadius; i+=50) {
                ctx.beginPath(); ctx.moveTo(i,-gameState.mapRadius); ctx.lineTo(i,gameState.mapRadius); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-gameState.mapRadius,i); ctx.lineTo(gameState.mapRadius,i); ctx.stroke();
            }

            // Objektumok
            gameState.coins.forEach(c => {
                ctx.beginPath(); ctx.arc(c.x, c.y, 8, 0, 6.28); ctx.fillStyle='#ffcc00'; ctx.fill();
            });
            gameState.bullets.forEach(b => {
                ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, 6.28); ctx.fillStyle='#ff0055'; ctx.fill();
            });

            // J√°t√©kosok
            Object.values(gameState.players).forEach(p => {
                if(p.isDead) return;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, 6.28);
                ctx.fillStyle = p.color; ctx.fill();
                ctx.shadowBlur=15; ctx.shadowColor=p.color; ctx.fill(); ctx.shadowBlur=0;
                
                // N√©v
                ctx.fillStyle='#fff'; ctx.font="bold 10px Roboto"; ctx.textAlign="center";
                ctx.fillText(p.name, p.x, p.y-25);
            });

            ctx.restore();
        }

        function updateHUD() {
            const m = Math.floor(gameState.timeLeft/60);
            const s = Math.floor(gameState.timeLeft%60).toString().padStart(2,'0');
            document.getElementById('game-timer').innerText = `${m}:${s}`;
            const modes = ["LOBBY", "TAG", "COIN", "SUMO"];
            document.getElementById('current-game-name').innerText = modes[gameState.gameMode];

            const list = Object.values(gameState.players).sort((a,b)=>b.score-a.score);
            document.getElementById('score-list').innerHTML = list.map(p=>`<div style="display:flex; justify-content:space-between; color:${p.color};"><span>${p.name}</span><span>${p.score}</span></div>`).join('');
        }

    </script>
</body>
</html>
