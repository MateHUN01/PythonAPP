<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Party Arena - P2P Multiplayer</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg: #0f0f13;
            --glass: rgba(255, 255, 255, 0.05);
            --border: rgba(255, 255, 255, 0.1);
            --accent: #00f2ff;
            --danger: #ff0055;
            --gold: #ffcc00;
        }
        body { margin: 0; background: var(--bg); color: white; font-family: 'Roboto', sans-serif; overflow: hidden; height: 100vh; user-select: none; }
        
        /* UI LAYOUT */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 10; }
        .pointer-events-auto { pointer-events: auto; }

        /* PANELEK */
        .panel { background: var(--glass); backdrop-filter: blur(10px); border: 1px solid var(--border); padding: 15px; border-radius: 12px; box-shadow: 0 4px 30px rgba(0,0,0,0.5); text-align: center; max-width: 300px; margin: 0 auto; transition: transform 0.2s; }
        .panel:hover { border-color: var(--accent); }

        h1 { font-family: 'Press Start 2P', cursive; color: var(--accent); font-size: 20px; text-shadow: 0 0 10px var(--accent); margin-bottom: 20px; }
        h2 { margin: 0 0 10px 0; font-size: 14px; opacity: 0.8; }

        /* INPUTOK & GOMBOK */
        input, select { background: rgba(0,0,0,0.3); border: 1px solid var(--border); color: white; padding: 8px; border-radius: 5px; width: 100%; margin-bottom: 10px; font-family: inherit; box-sizing: border-box;}
        button { background: var(--accent); color: #000; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; width: 100%; transition: 0.2s; font-family: 'Press Start 2P', cursive; font-size: 10px; margin-bottom: 5px;}
        button:hover { transform: scale(1.05); box-shadow: 0 0 15px var(--accent); }
        button.secondary { background: transparent; border: 1px solid var(--border); color: #ccc; }
        button.secondary:hover { background: rgba(255,255,255,0.1); }

        /* J√ÅT√âK CANVAS */
        canvas { display: block; width: 100%; height: 100%; background: radial-gradient(circle at center, #1a1a24 0%, #000000 100%); image-rendering: pixelated; }

        /* MENU SCREEN */
        #menu-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        
        /* HUD */
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; }
        .score-board { text-align: left; font-family: 'Press Start 2P'; font-size: 12px; line-height: 1.5; }
        .game-info { text-align: center; }
        .timer { font-size: 30px; font-weight: bold; font-family: 'Press Start 2P'; color: var(--gold); text-shadow: 0 0 10px var(--gold); }
        .game-title { color: #aaa; font-size: 12px; margin-bottom: 5px; }

        /* GAME CONTROLS (HOST ONLY) */
        #host-controls { display: none; margin-top: 10px; }

        /* LOBBY AVATAR PREVIEW */
        .color-picker { display: flex; gap: 5px; justify-content: center; margin-bottom: 10px; }
        .color-btn { width: 30px; height: 30px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: 0.2s; }
        .color-btn.selected { border-color: white; transform: scale(1.2); }

    </style>
</head>
<body>

    <div id="menu-screen">
        <div class="panel pointer-events-auto">
            <h1>NEON PARTY</h1>
            
            <div style="margin-bottom: 15px;">
                <label style="font-size:12px; display:block; margin-bottom:5px;">Neved:</label>
                <input type="text" id="username" placeholder="J√°t√©kos neve" maxlength="10">
                
                <label style="font-size:12px; display:block; margin-bottom:5px;">Sz√≠ned:</label>
                <div class="color-picker" id="color-picker">
                    </div>
            </div>

            <div style="border-top: 1px solid var(--border); padding-top: 15px; margin-top: 15px;">
                <h2>√öj J√°t√©k (HOST)</h2>
                <button onclick="startHost()">SZOBA L√âTREHOZ√ÅSA</button>
            </div>

            <div style="border-top: 1px solid var(--border); padding-top: 15px; margin-top: 15px;">
                <h2>Csatlakoz√°s (JOIN)</h2>
                <input type="text" id="join-id" placeholder="Szoba ID (Hostt√≥l k√©rd el)">
                <button class="secondary" onclick="joinGame()">CSATLAKOZ√ÅS</button>
            </div>
            
            <div id="status-msg" style="margin-top:10px; font-size:12px; color:var(--accent); height:20px;"></div>
        </div>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="panel pointer-events-auto score-board">
                <div style="color:#888; border-bottom:1px solid #333; margin-bottom:5px;">RANGLISTA</div>
                <div id="score-list">V√°rakoz√°s...</div>
            </div>

            <div class="game-info">
                <div class="game-title" id="current-game-name">LOBBY</div>
                <div class="timer" id="game-timer">--:--</div>
                
                <div id="host-controls" class="panel pointer-events-auto" style="margin-top:10px; padding:10px;">
                    <select id="game-selector">
                        <option value="1">üéÆ Space Tag (L√∂v√∂ld√∂z≈ës)</option>
                        <option value="2">üü° Coin Rush (√ârm√©k)</option>
                        <option value="3">üîµ Sumo Push (L√∂kd√∂s≈ë)</option>
                    </select>
                    <button onclick="hostStartGame()">J√ÅT√âK IND√çT√ÅSA</button>
                </div>
            </div>

            <div class="panel pointer-events-auto">
                <div style="font-size:10px; color:#888;">SZOBA ID:</div>
                <div id="room-id-display" style="font-weight:bold; user-select:text; cursor:pointer;" onclick="navigator.clipboard.writeText(this.innerText); alert('ID M√°solva!')">-</div>
            </div>
        </div>

        <div style="text-align:center; opacity:0.6; font-size:12px;">
            Mozg√°s: <b>WASD</b> vagy <b>NYILAK</b> | Akci√≥: <b>SPACE</b>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- KONFIGUR√ÅCI√ì & V√ÅLTOZ√ìK ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Sz√≠nek
        const COLORS = ['#ff0055', '#00f2ff', '#00ff44', '#ffcc00', '#aa00ff', '#ffffff'];
        let myColor = COLORS[Math.floor(Math.random() * COLORS.length)];
        let myName = "Player" + Math.floor(Math.random()*100);
        
        // PeerJS
        let peer, conn;
        let myId = null;
        let hostId = null;
        let isHost = false;
        let connections = []; // Csak hostnak

        // J√°t√©k √Ållapot (STATE) - Ezt szinkroniz√°ljuk
        let gameState = {
            players: {}, // id -> {x, y, color, name, score, vx, vy, cooldown, isDead}
            bullets: [], // {x, y, vx, vy, ownerId}
            coins: [],   // {x, y, value}
            gameMode: 0, // 0: Lobby, 1: Tag, 2: Coins, 3: Sumo
            timeLeft: 0,
            isPlaying: false,
            mapRadius: 0
        };

        // Bemenet
        const keys = { w:false, a:false, s:false, d:false, space:false };

        // --- INICIALIZ√ÅL√ÅS ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(isHost) gameState.mapRadius = Math.min(canvas.width, canvas.height) * 0.4;
        }
        window.addEventListener('resize', resize);
        resize();

        // Sz√≠nv√°laszt√≥ UI
        const colorContainer = document.getElementById('color-picker');
        COLORS.forEach(c => {
            const d = document.createElement('div');
            d.className = 'color-btn';
            d.style.backgroundColor = c;
            d.onclick = () => {
                myColor = c;
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
                d.classList.add('selected');
            };
            if(c === myColor) d.classList.add('selected');
            colorContainer.appendChild(d);
        });

        // --- H√ÅL√ìZATI LOGIKA (PEERJS) ---

        function initPeer(id = null) {
            peer = new Peer(id, { debug: 1 });
            
            peer.on('open', (id) => {
                myId = id;
                document.getElementById('status-msg').innerText = "Kapcsol√≥dva a h√°l√≥zathoz!";
                console.log('My ID:', id);
            });

            peer.on('connection', (c) => {
                // Ha HOST vagyok, fogadom a csatlakoz√°st
                if (isHost) {
                    c.on('data', (data) => handleHostData(c, data));
                    c.on('open', () => {
                        connections.push(c);
                        // √öj j√°t√©kos inicializ√°l√°sa
                        spawnPlayer(c.peer, "Guest", "#fff");
                        broadcastState();
                    });
                    c.on('close', () => {
                        delete gameState.players[c.peer];
                        connections = connections.filter(conn => conn.peer !== c.peer);
                    });
                }
            });

            peer.on('error', (err) => alert("Hiba: " + err));
        }

        function startHost() {
            myName = document.getElementById('username').value || myName;
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('host-controls').style.display = 'block';
            isHost = true;
            
            initPeer();
            
            peer.on('open', (id) => {
                document.getElementById('room-id-display').innerText = id;
                spawnPlayer(id, myName, myColor);
                gameState.mapRadius = Math.min(canvas.width, canvas.height) * 0.4;
                gameLoop(); // Host ind√≠tja a f≈ë ciklust
            });
        }

        function joinGame() {
            myName = document.getElementById('username').value || myName;
            hostId = document.getElementById('join-id').value;
            if(!hostId) return alert("Add meg a szoba ID-t!");

            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('room-id-display').innerText = hostId;
            isHost = false;

            initPeer(); // Saj√°t ID gener√°l√°s

            peer.on('open', () => {
                conn = peer.connect(hostId);
                conn.on('open', () => {
                    // Bek√∂sz√∂n√©s
                    conn.send({ type: 'join', name: myName, color: myColor });
                });
                conn.on('data', (data) => {
                    // Kliens oldali adatfogad√°s
                    if (data.type === 'update') {
                        gameState = data.state;
                        // Kliens is rajzol
                        render(); 
                        updateHUD();
                    }
                });
            });
        }

        // --- HOST LOGIKA (A J√ÅT√âK AGYA) ---

        function handleHostData(conn, data) {
            if (data.type === 'join') {
                gameState.players[conn.peer].name = data.name;
                gameState.players[conn.peer].color = data.color;
            }
            if (data.type === 'input') {
                // J√°t√©kos bemenet√©nek feldolgoz√°sa
                const p = gameState.players[conn.peer];
                if (p && !p.isDead) {
                    applyInput(p, data.keys);
                }
            }
        }

        function spawnPlayer(id, name, color) {
            gameState.players[id] = {
                id: id,
                x: 0, y: 0, // K√∂z√©pre rakja majd a reset
                vx: 0, vy: 0,
                color: color,
                name: name,
                score: 0,
                cooldown: 0,
                isDead: false,
                radius: 15
            };
        }

        function hostStartGame() {
            const mode = parseInt(document.getElementById('game-selector').value);
            gameState.gameMode = mode;
            gameState.timeLeft = 60; // 60 mp k√∂r√∂k
            gameState.isPlaying = true;
            gameState.bullets = [];
            gameState.coins = [];
            
            // Mindenkit respawnolunk
            const playerIds = Object.keys(gameState.players);
            playerIds.forEach((id, index) => {
                const p = gameState.players[id];
                p.score = 0;
                p.isDead = false;
                p.vx = 0; p.vy = 0;
                // K√∂rben elhelyez√©s
                const angle = (index / playerIds.length) * Math.PI * 2;
                const dist = gameState.mapRadius * 0.5;
                p.x = Math.cos(angle) * dist;
                p.y = Math.sin(angle) * dist;
            });

            // Coin Rush eset√©n √©rm√©k
            if (mode === 2) {
                for(let i=0; i<20; i++) spawnCoin();
            }
        }

        function spawnCoin() {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * (gameState.mapRadius - 20);
            gameState.coins.push({
                x: Math.cos(angle) * dist,
                y: Math.sin(angle) * dist,
                value: 1
            });
        }

        function gameLoop() {
            if (!isHost) return;

            // 1. Saj√°t input feldolgoz√°sa
            if (gameState.players[myId] && !gameState.players[myId].isDead) {
                applyInput(gameState.players[myId], keys);
            }

            // 2. Fizika √©s J√°t√©kszab√°lyok
            updatePhysics();

            // 3. Szinkroniz√°ci√≥
            broadcastState();

            // 4. Renderel√©s (Hostnak is l√°tnia kell)
            render();
            updateHUD();

            requestAnimationFrame(gameLoop);
        }

        function applyInput(p, inputKeys) {
            const speed = 0.5; // Gyorsul√°s
            if (inputKeys.w) p.vy -= speed;
            if (inputKeys.s) p.vy += speed;
            if (inputKeys.a) p.vx -= speed;
            if (inputKeys.d) p.vx += speed;

            // SPACE AKCI√ìK
            if (inputKeys.space && p.cooldown <= 0 && gameState.isPlaying) {
                if (gameState.gameMode === 1) { // L√ñV√âS
                    const angle = Math.atan2(p.vy, p.vx) || 0; // Mozg√°s ir√°ny√°ba, vagy jobbra
                    // Ha √°ll, akkor az eg√©r fel√© k√©ne, de egyszer≈±s√≠tve: amerre legut√≥bb mozgott
                    // Vagy v√©letlenszer≈± ha √°ll? Legyen ink√°bb a mozg√°s ir√°nya
                    let bx = p.vx !== 0 || p.vy !== 0 ? p.vx : 1;
                    let by = p.vy !== 0 || p.vy !== 0 ? p.vy : 0;
                    // Normaliz√°l√°s
                    const len = Math.sqrt(bx*bx + by*by);
                    bx /= len; by /= len;

                    gameState.bullets.push({
                        x: p.x + bx * 20,
                        y: p.y + by * 20,
                        vx: bx * 10,
                        vy: by * 10,
                        ownerId: p.id
                    });
                    p.cooldown = 30; // 0.5 mp
                }
            }
            if (p.cooldown > 0) p.cooldown--;
        }

        function updatePhysics() {
            // Id≈ëz√≠t≈ë
            if (gameState.isPlaying && gameState.timeLeft > 0) {
                gameState.timeLeft -= 1/60;
                if (gameState.timeLeft <= 0) {
                    gameState.isPlaying = false;
                    gameState.timeLeft = 0;
                    gameState.gameMode = 0; // Vissza lobbyba
                }
            }

            // J√°t√©kosok mozgat√°sa
            Object.values(gameState.players).forEach(p => {
                if (p.isDead) return;

                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.92; // S√∫rl√≥d√°s
                p.vy *= 0.92;

                // Hat√°rok (K√∂r alak√∫ p√°lya)
                const dist = Math.sqrt(p.x*p.x + p.y*p.y);
                const limit = gameState.mapRadius - p.radius;

                if (dist > limit) {
                    if (gameState.gameMode === 3 && gameState.isPlaying) {
                        // SUMO MODE: Kies√©s
                        p.isDead = true;
                        // Aki utolj√°ra meg√ºt√∂tte? (Ezt most egyszer≈±s√≠tve hagyjuk)
                    } else {
                        // Falnak √ºtk√∂z√©s (Visszapattan√°s)
                        const angle = Math.atan2(p.y, p.x);
                        p.x = Math.cos(angle) * limit;
                        p.y = Math.sin(angle) * limit;
                    }
                }

                // Coin gy≈±jt√©s
                if (gameState.gameMode === 2 && gameState.isPlaying) {
                    for (let i = gameState.coins.length - 1; i >= 0; i--) {
                        const c = gameState.coins[i];
                        const dx = p.x - c.x;
                        const dy = p.y - c.y;
                        if (Math.sqrt(dx*dx + dy*dy) < p.radius + 10) {
                            gameState.coins.splice(i, 1);
                            p.score++;
                            spawnCoin(); // √öj √©rme
                        }
                    }
                }
            });

            // √útk√∂z√©sek j√°t√©kosok k√∂z√∂tt (Sumo l√∂kd√∂s≈ëd√©s)
            const pIds = Object.keys(gameState.players);
            for (let i = 0; i < pIds.length; i++) {
                for (let j = i + 1; j < pIds.length; j++) {
                    const p1 = gameState.players[pIds[i]];
                    const p2 = gameState.players[pIds[j]];
                    if(p1.isDead || p2.isDead) continue;

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const minDist = p1.radius + p2.radius;

                    if (dist < minDist) {
                        // √útk√∂z√©s!
                        const angle = Math.atan2(dy, dx);
                        const force = 1.0; // L√∂k√©s ereje
                        const pushX = Math.cos(angle) * force;
                        const pushY = Math.sin(angle) * force;

                        // Sumo m√≥dban er≈ësebb l√∂k√©s
                        const mult = (gameState.gameMode === 3) ? 3 : 1;

                        p1.vx -= pushX * mult;
                        p1.vy -= pushY * mult;
                        p2.vx += pushX * mult;
                        p2.vy += pushY * mult;

                        // Egym√°sb√≥l kil√∂k√©s, hogy ne ragadjanak √∂ssze
                        const overlap = minDist - dist;
                        const sepX = (dx / dist) * overlap * 0.5;
                        const sepY = (dy / dist) * overlap * 0.5;
                        p1.x -= sepX; p1.y -= sepY;
                        p2.x += sepX; p2.y += sepY;
                    }
                }
            }

            // L√∂ved√©kek
            if (gameState.gameMode === 1) {
                for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                    const b = gameState.bullets[i];
                    b.x += b.vx;
                    b.y += b.vy;

                    // T√∂rl√©s ha kimegy a p√°ly√°r√≥l
                    if (Math.sqrt(b.x*b.x + b.y*b.y) > gameState.mapRadius) {
                        gameState.bullets.splice(i, 1);
                        continue;
                    }

                    // Tal√°lat vizsg√°lat
                    for (let pid in gameState.players) {
                        const p = gameState.players[pid];
                        if (p.id !== b.ownerId && !p.isDead) {
                            const dx = p.x - b.x;
                            const dy = p.y - b.y;
                            if (Math.sqrt(dx*dx + dy*dy) < p.radius + 5) {
                                // Tal√°lat!
                                p.score = Math.max(0, p.score - 1); // Tal√°lt vesz√≠t pontot
                                if(gameState.players[b.ownerId]) gameState.players[b.ownerId].score++; // L√∂v≈ë kap pontot
                                
                                // Respawn effekt (csak arr√©bb rakjuk)
                                p.x = (Math.random()-0.5)*100;
                                p.y = (Math.random()-0.5)*100;
                                p.vx = 0; p.vy = 0;

                                gameState.bullets.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        }

        function broadcastState() {
            const data = { type: 'update', state: gameState };
            connections.forEach(c => c.send(data));
        }

        // --- KLIENS BEMENET KEZEL√âS ---
        
        window.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            if (keys.hasOwnProperty(k) || k === ' ') {
                if(k === ' ') keys.space = true;
                else keys[k] = true;
                sendInput();
            }
        });

        window.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if (keys.hasOwnProperty(k) || k === ' ') {
                if(k === ' ') keys.space = false;
                else keys[k] = false;
                sendInput();
            }
        });

        function sendInput() {
            if (isHost) return; // Host k√∂zvetlen√ºl √≠rja a state-et
            if (conn && conn.open) {
                conn.send({ type: 'input', keys: keys });
            }
        }

        // --- RENDEREL√âS (GRAFIKA) ---

        function render() {
            // T√∂rl√©s
            ctx.fillStyle = '#0f0f13';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Koordin√°ta rendszer eltol√°sa k√∂z√©pre
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);

            // P√°lya rajzol√°sa
            ctx.beginPath();
            ctx.arc(0, 0, gameState.mapRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#14141c';
            ctx.fill();
            ctx.lineWidth = 5;
            // Keret sz√≠ne j√°t√©km√≥d szerint
            if(gameState.gameMode === 1) ctx.strokeStyle = '#ff0055'; // Red
            else if(gameState.gameMode === 2) ctx.strokeStyle = '#ffcc00'; // Gold
            else if(gameState.gameMode === 3) ctx.strokeStyle = '#00f2ff'; // Blue
            else ctx.strokeStyle = '#333';
            ctx.stroke();

            // R√°cs (D√≠sz√≠t√©s)
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for(let i = -gameState.mapRadius; i < gameState.mapRadius; i+=gridSize) {
                ctx.beginPath(); ctx.moveTo(i, -gameState.mapRadius); ctx.lineTo(i, gameState.mapRadius); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(-gameState.mapRadius, i); ctx.lineTo(gameState.mapRadius, i); ctx.stroke();
            }

            // √ârm√©k
            gameState.coins.forEach(c => {
                ctx.beginPath();
                ctx.arc(c.x, c.y, 8, 0, Math.PI*2);
                ctx.fillStyle = '#ffcc00';
                ctx.fill();
                ctx.shadowBlur = 10; ctx.shadowColor = '#ffcc00';
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#000';
                ctx.font = "10px Arial";
                ctx.fillText("$", c.x-3, c.y+3);
            });

            // L√∂ved√©kek
            ctx.fillStyle = '#ff0055';
            gameState.bullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, 4, 0, Math.PI*2);
                ctx.fill();
            });

            // J√°t√©kosok
            Object.values(gameState.players).forEach(p => {
                if (p.isDead) return;

                // Test
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
                
                // Glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = p.color;
                ctx.fill();
                ctx.shadowBlur = 0;

                // Szemek (Ir√°ny jelz√©se a sebess√©g alapj√°n)
                const lookX = p.vx * 3;
                const lookY = p.vy * 3;
                
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.arc(p.x - 5 + lookX, p.y - 5 + lookY, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(p.x + 5 + lookX, p.y - 5 + lookY, 4, 0, Math.PI*2); ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath(); ctx.arc(p.x - 5 + lookX, p.y - 5 + lookY, 2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(p.x + 5 + lookX, p.y - 5 + lookY, 2, 0, Math.PI*2); ctx.fill();

                // N√©v
                ctx.fillStyle = '#fff';
                ctx.font = "bold 10px Roboto";
                ctx.textAlign = "center";
                ctx.fillText(p.name, p.x, p.y - 25);
            });

            ctx.restore();
        }

        function updateHUD() {
            // Timer
            const m = Math.floor(gameState.timeLeft / 60);
            const s = Math.floor(gameState.timeLeft % 60).toString().padStart(2, '0');
            document.getElementById('game-timer').innerText = `${m}:${s}`;

            // J√°t√©km√≥d ki√≠r√°sa
            const modes = ["V√ÅR√ìTEREM (Gyakorl√°s)", "SPACE TAG (L√∂v√∂ld√∂z≈ës)", "COIN RUSH (√ârm√©k)", "SUMO PUSH (L√∂kd√∂s≈ë)"];
            document.getElementById('current-game-name').innerText = modes[gameState.gameMode];

            // Ranglista
            const sortedPlayers = Object.values(gameState.players).sort((a,b) => b.score - a.score);
            let html = "";
            sortedPlayers.forEach(p => {
                html += `<div style="display:flex; justify-content:space-between; color:${p.color}; margin-bottom:4px;">
                    <span>${p.name}</span>
                    <span>${p.score}</span>
                </div>`;
            });
            document.getElementById('score-list').innerHTML = html;
        }

    </script>
</body>
</html>
